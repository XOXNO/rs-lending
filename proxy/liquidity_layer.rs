// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LiquidityPoolProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LiquidityPoolProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LiquidityPoolProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LiquidityPoolProxyMethods { wrapped_tx: tx }
    }
}

pub struct LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LiquidityPoolProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes a new liquidity pool with asset configuration and interest rate parameters. 
    /// Sets up initial indexes (RAY), validates rate parameters, and records pool asset details. 
    /// All supplied/borrowed/revenue amounts start at zero. 
    pub fn init<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
        Arg9: ProxyArg<usize>,
    >(
        self,
        asset: Arg0,
        max_borrow_rate: Arg1,
        base_borrow_rate: Arg2,
        slope1: Arg3,
        slope2: Arg4,
        slope3: Arg5,
        mid_utilization: Arg6,
        optimal_utilization: Arg7,
        reserve_factor: Arg8,
        asset_decimals: Arg9,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&asset)
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .argument(&asset_decimals)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Handles contract upgrade with empty implementation. 
    /// Allows code updates without state migration requirements. 
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Updates pool interest rate parameters and reserve factor. 
    /// Validates new parameters and emits event for transparency. 
    /// Only callable by owner. 
    pub fn update_params<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        max_borrow_rate: Arg0,
        base_borrow_rate: Arg1,
        slope1: Arg2,
        slope2: Arg3,
        slope3: Arg4,
        mid_utilization: Arg5,
        optimal_utilization: Arg6,
        reserve_factor: Arg7,
        asset_price: Arg8,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateParams")
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .argument(&asset_price)
            .original_result()
    }

    /// Retrieves the total scaled amount supplied to the pool. 
    /// This value represents the sum of all supplied principals, each divided by the supply index at the time of their deposit. 
    /// It is stored RAY-scaled. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The total scaled amount supplied, RAY-scaled. 
    pub fn supplied(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSuppliedScaled")
            .original_result()
    }

    /// Retrieves the protocol revenue accrued from borrow interest fees. 
    /// This value is stored RAY-scaled. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The accumulated protocol revenue, RAY-scaled. 
    pub fn revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRevenueScaled")
            .original_result()
    }

    /// Retrieves the total scaled borrowed amount from the pool. 
    /// This value represents the sum of all borrowed principals, each divided by the borrow index at the time of their borrowing. 
    /// It is stored RAY-scaled. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The total scaled borrowed amount, RAY-scaled. 
    pub fn borrowed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowedScaled")
            .original_result()
    }

    /// Returns the market parameters. 
    ///  
    /// These include interest rate parameters and asset decimals. 
    ///  
    /// # Returns 
    /// - `MarketParams<Self::Api>`: The market configuration. 
    pub fn parameters(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::MarketParams<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getParameters")
            .original_result()
    }

    /// Retrieves the current borrow index. 
    ///  
    /// The borrow index is used to calculate accrued interest on borrow positions. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current borrow index. 
    pub fn borrow_index(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowIndex")
            .original_result()
    }

    /// Retrieves the current supply index. 
    ///  
    /// The supply index is used to compute the yield for suppliers. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current supply index. 
    pub fn supply_index(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSupplyIndex")
            .original_result()
    }

    /// Retrieves the last update timestamp for the interest indexes. 
    ///  
    /// # Returns 
    /// - `u64`: The timestamp when indexes were last updated, stored in milliseconds since Unix epoch. 
    pub fn last_timestamp(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastTimestamp")
            .original_result()
    }

    /// Updates borrow and supply indexes based on elapsed time since last update. 
    /// Synchronizes global pool state and emits market update event. 
    /// Returns current market indexes. 
    pub fn update_indexes<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        price: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::MarketIndex<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateIndexes")
            .argument(&price)
            .original_result()
    }

    /// Processes asset deposit, adding to reserves and updating supplier position. 
    /// Validates payment asset and converts amount to scaled tokens. 
    /// Returns updated position with accrued interest. 
    pub fn supply<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        price: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .raw_call("supply")
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Borrows assets against collateral, transferring funds to caller. 
    /// Validates sufficient liquidity and updates debt position. 
    /// Returns updated borrow position. 
    pub fn borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg3: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        amount: Arg1,
        position: Arg2,
        price: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrow")
            .argument(&initial_caller)
            .argument(&amount)
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Withdraws assets from supply position, handling liquidation fees if applicable. 
    /// Supports full/partial withdrawals and burns corresponding scaled tokens. 
    /// Returns updated position with reduced supply. 
    pub fn withdraw<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg3: ProxyArg<bool>,
        Arg4: ProxyArg<Option<ManagedDecimal<Env::Api, usize>>>,
        Arg5: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        amount: Arg1,
        position: Arg2,
        is_liquidation: Arg3,
        protocol_fee_opt: Arg4,
        price: Arg5,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdraw")
            .argument(&initial_caller)
            .argument(&amount)
            .argument(&position)
            .argument(&is_liquidation)
            .argument(&protocol_fee_opt)
            .argument(&price)
            .original_result()
    }

    /// Repays borrowed amount, reducing debt and refunding overpayments. 
    /// Handles both full and partial repayments with interest included. 
    /// Returns updated position with reduced debt. 
    pub fn repay<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg2: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        position: Arg1,
        price: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .raw_call("repay")
            .argument(&initial_caller)
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Provides atomic flash loan with fee collection. 
    /// Transfers amount to target contract, validates repayment, adds protocol revenue. 
    /// Must be repaid with fees in same transaction. 
    pub fn flash_loan<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<ManagedArgBuffer<Env::Api>>,
        Arg5: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg6: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        borrowed_token: Arg0,
        amount: Arg1,
        contract_address: Arg2,
        endpoint: Arg3,
        arguments: Arg4,
        fees: Arg5,
        price: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("flashLoan")
            .argument(&borrowed_token)
            .argument(&amount)
            .argument(&contract_address)
            .argument(&endpoint)
            .argument(&arguments)
            .argument(&fees)
            .argument(&price)
            .original_result()
    }

    /// Creates leveraged position by borrowing with upfront fee deduction. 
    /// User receives (amount - fee) but owes full amount plus interest. 
    /// Returns updated position with increased debt. 
    pub fn create_strategy<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg3: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        strategy_amount: Arg1,
        strategy_fee: Arg2,
        price: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createStrategy")
            .argument(&position)
            .argument(&strategy_amount)
            .argument(&strategy_fee)
            .argument(&price)
            .original_result()
    }

    /// Socializes bad debt by reducing supply index or seizes dust collateral. 
    /// For borrow positions: applies loss to all suppliers immediately. 
    /// For supply positions: adds dust to protocol revenue. 
    pub fn seize_position<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        price: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("seizePosition")
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Claims accumulated protocol revenue and transfers to owner. 
    /// Revenue includes interest spreads, fees, and liquidation penalties. 
    /// Limited by available reserves to preserve user withdrawals. 
    pub fn claim_revenue<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        price: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRevenue")
            .argument(&price)
            .original_result()
    }

    /// Returns current pool utilization ratio (borrowed_value / supplied_value). 
    /// Used for interest rate calculations and pool health monitoring. 
    /// Returns 0 if no supply exists. 
    pub fn capital_utilisation(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("capitalUtilisation")
            .original_result()
    }

    /// Returns total asset balance held by pool contract. 
    /// Represents immediately available liquidity for withdrawals and loans. 
    /// Balance changes with deposits, withdrawals, borrows, and repayments. 
    pub fn reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reserves")
            .original_result()
    }

    /// Returns current annual percentage yield for suppliers. 
    /// Calculated as: borrow_rate * utilization * (1 - reserve_factor). 
    /// Higher utilization and borrow rates increase deposit yields. 
    pub fn deposit_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("depositRate")
            .original_result()
    }

    /// Returns current annual percentage rate for borrowers. 
    /// Uses piecewise linear rate model with kink point. 
    /// Rates increase steeply above optimal utilization to protect liquidity. 
    pub fn borrow_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrowRate")
            .original_result()
    }

    /// Returns milliseconds elapsed since last pool synchronization. 
    /// Indicates accumulated interest awaiting index updates. 
    /// Larger deltas mean more pending interest calculations. 
    pub fn delta_time(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("deltaTime")
            .original_result()
    }

    /// Returns accumulated protocol revenue value in asset decimals. 
    /// Revenue from interest spreads, fees, and liquidations. 
    /// Stored as scaled tokens that appreciate with supply index. 
    pub fn protocol_revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("protocolRevenue")
            .original_result()
    }

    /// Returns total value of all deposits including accrued interest. 
    /// Includes user deposits, earned interest, and protocol revenue. 
    /// Grows through deposits and supply index appreciation. 
    pub fn supplied_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("suppliedAmount")
            .original_result()
    }

    /// Returns total debt owed by all borrowers including accrued interest. 
    /// Includes principal and compound interest through borrow index. 
    /// Grows through new borrows and interest accrual over time. 
    pub fn borrowed_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrowedAmount")
            .original_result()
    }
}
