// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct ControllerProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for ControllerProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = ControllerProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        ControllerProxyMethods { wrapped_tx: tx }
    }
}

pub struct ControllerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> ControllerProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the lending pool contract with required addresses. 
    ///  
    /// # Arguments 
    /// - `lp_template_address`: Address of the liquidity pool template. 
    /// - `price_aggregator_address`: Address of the price aggregator. 
    /// - `safe_price_view_address`: Address for safe price views. 
    /// - `accumulator_address`: Address for revenue accumulation. 
    /// - `wegld_address`: Address for wrapped EGLD. 
    /// - `swap_router_address`: Address for Swap Router integration. 
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
        Arg5: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        lp_template_address: Arg0,
        price_aggregator_address: Arg1,
        safe_price_view_address: Arg2,
        accumulator_address: Arg3,
        wegld_address: Arg4,
        swap_router_address: Arg5,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&lp_template_address)
            .argument(&price_aggregator_address)
            .argument(&safe_price_view_address)
            .argument(&accumulator_address)
            .argument(&wegld_address)
            .argument(&swap_router_address)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> ControllerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        _assets: Arg0,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .argument(&_assets)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> ControllerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Supplies collateral to the lending pool. 
    ///  
    /// # Arguments 
    /// - `is_vault`: Indicates if the supply is for a vault position. 
    /// - `e_mode_category`: Optional e-mode category for specialized parameters. 
    ///  
    /// # Payment 
    /// - Accepts minimum 1 payment: optional account NFT and bulk collateral tokens. 
    pub fn supply<
        Arg0: ProxyArg<OptionalValue<u64>>,
        Arg1: ProxyArg<OptionalValue<u8>>,
    >(
        self,
        opt_account_nonce: Arg0,
        e_mode_category: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("supply")
            .argument(&opt_account_nonce)
            .argument(&e_mode_category)
            .original_result()
    }

    /// Withdraws collateral from the lending pool. 
    ///  
    /// # Arguments 
    /// - `collaterals`: List of tokens and amounts to withdraw. 
    ///  
    /// # Payment 
    /// - Requires account NFT payment. 
    pub fn withdraw<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>>,
    >(
        self,
        collaterals: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("withdraw")
            .argument(&collaterals)
            .original_result()
    }

    /// Borrows assets from the lending pool. 
    ///  
    /// # Arguments 
    /// - `borrowed_tokens`: List of tokens and amounts to borrow. 
    ///  
    /// # Payment 
    /// - Requires account NFT payment. 
    pub fn borrow<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>>,
    >(
        self,
        borrowed_tokens: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("borrow")
            .argument(&borrowed_tokens)
            .original_result()
    }

    /// Repays borrowed assets for an account. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    pub fn repay<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("repay")
            .argument(&account_nonce)
            .original_result()
    }

    /// Liquidates an unhealthy position. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account to liquidate. 
    pub fn liquidate<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("liquidate")
            .argument(&account_nonce)
            .original_result()
    }

    /// Executes a flash loan. 
    ///  
    /// # Arguments 
    /// - `borrowed_asset_id`: Token identifier to borrow. 
    /// - `amount`: Amount to borrow. 
    /// - `contract_address`: Address of the contract to receive the loan. 
    /// - `endpoint`: Endpoint to call on the receiving contract. 
    /// - `arguments`: Arguments for the endpoint call. 
    pub fn flash_loan<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<ManagedArgBuffer<Env::Api>>,
    >(
        self,
        borrowed_asset_id: Arg0,
        amount: Arg1,
        contract_address: Arg2,
        endpoint: Arg3,
        arguments: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("flashLoan")
            .argument(&borrowed_asset_id)
            .argument(&amount)
            .argument(&contract_address)
            .argument(&endpoint)
            .argument(&arguments)
            .original_result()
    }

    /// Updates LTV or liquidation threshold for account positions of a specific asset. 
    ///  
    /// # Arguments 
    /// - `asset_id`: Token identifier to update. 
    /// - `is_ltv`: True to update LTV, false for liquidation threshold. 
    /// - `account_nonces`: List of account nonces to update. 
    pub fn update_account_threshold<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<MultiValueEncoded<Env::Api, u64>>,
    >(
        self,
        asset_id: Arg0,
        has_risks: Arg1,
        account_nonces: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountThreshold")
            .argument(&asset_id)
            .argument(&has_risks)
            .argument(&account_nonces)
            .original_result()
    }

    /// Updates interest rate indexes for specified assets. 
    ///  
    /// # Arguments 
    /// - `assets`: List of token identifiers to update. 
    pub fn update_indexes<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateIndexes")
            .argument(&assets)
            .original_result()
    }

    /// Cleans bad debt from an account. 
    ///  
    /// It seizes all remaining collateral + interest and adds all remaining debt as bad debt, 
    /// then cleans isolated debt if any. 
    /// In case of a vault, it toggles the account to non-vault to move funds to the shared liquidity pool. 
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account to clean. 
    pub fn clean_bad_debt<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cleanBadDebt")
            .argument(&account_nonce)
            .original_result()
    }

    /// Deploys a complete liquidity pool with comprehensive asset configuration. 
    ///  
    /// **Purpose**: Creates a new lending market for an asset by deploying a liquidity pool 
    /// and configuring all necessary risk parameters, interest rate models, and operational 
    /// settings. This is the primary governance function for onboarding new assets. 
    ///  
    /// **How it works**: 
    /// 1. **Pre-deployment validation**: 
    ///    - Ensures asset doesn't already have a pool 
    ///    - Validates asset identifier format 
    ///    - Confirms liquidation threshold > LTV ratio 
    ///  
    /// 2. **Pool deployment**: 
    ///    - Deploys new pool from secure template 
    ///    - Initializes with interest rate model parameters 
    ///    - Registers pool address in protocol mapping 
    ///  
    /// 3. **Asset configuration**: 
    ///    - Sets up comprehensive risk parameters 
    ///    - Configures lending/borrowing permissions 
    ///    - Establishes supply/borrow caps and isolation settings 
    ///    - Initializes isolated debt tracking 
    ///  
    /// 4. **Event emission**: 
    ///    - Emits market creation event for transparency 
    ///    - Includes all configuration parameters for auditing 
    ///  
    /// **Interest rate model parameters**: 
    /// ``` 
    /// utilization_rate = total_borrows / total_supply 
    ///  
    /// if utilization <= optimal_utilization: 
    ///     rate = base_rate + (utilization * slope1 / optimal_utilization) 
    /// elif utilization <= mid_utilization: 
    ///     rate = base_rate + slope1 + ((utilization - optimal) * slope2 / (mid - optimal)) 
    /// else: 
    ///     rate = base_rate + slope1 + slope2 + ((utilization - mid) * slope3 / (100% - mid)) 
    ///  
    /// borrow_rate = min(calculated_rate, max_borrow_rate) 
    /// ``` 
    ///  
    /// **Risk parameter validation**: 
    /// - **LTV < Liquidation Threshold**: Ensures safety buffer between borrowing and liquidation 
    /// - **Valid asset identifier**: Prevents deployment for invalid tokens 
    /// - **Reasonable parameter bounds**: Protects against extreme risk configurations 
    ///  
    /// **Asset configuration mechanics**: 
    /// - **Isolation mode**: Assets can be restricted to isolation-only usage 
    /// - **Siloed borrowing**: Prevents borrowing multiple assets simultaneously 
    /// - **Supply/Borrow caps**: Limits maximum exposure to prevent concentration risk 
    /// - **Flash loan settings**: Configures flash loan availability and fees 
    ///  
    /// **Security considerations**: 
    /// - Template-based deployment ensures consistent security standards 
    /// - Comprehensive parameter validation prevents misconfiguration 
    /// - Asset uniqueness check prevents duplicate markets 
    /// - Owner-only access ensures governance control 
    ///  
    /// **Governance impact**: 
    /// Creates new lending market with immediate availability for users. 
    /// All parameters can be adjusted later through edit functions. 
    ///  
    /// # Arguments 
    /// - `base_asset`: Token identifier for the new market asset 
    /// - `max_borrow_rate`: Interest rate ceiling (basis points) 
    /// - `base_borrow_rate`: Minimum interest rate (basis points) 
    /// - `slope1`: Rate increase slope for 0% to optimal utilization 
    /// - `slope2`: Rate increase slope for optimal to mid utilization   
    /// - `slope3`: Rate increase slope for mid to 100% utilization 
    /// - `mid_utilization`: Mid-range utilization threshold (basis points) 
    /// - `optimal_utilization`: Target utilization rate (basis points) 
    /// - `reserve_factor`: Protocol fee percentage (basis points) 
    /// - `ltv`: Maximum loan-to-value ratio (basis points) 
    /// - `liquidation_threshold`: Liquidation trigger threshold (basis points) 
    /// - `liquidation_base_bonus`: Base liquidator reward (basis points) 
    /// - `liquidation_max_fee`: Maximum liquidation fee (basis points) 
    /// - `can_be_collateral`: Whether asset can secure loans 
    /// - `can_be_borrowed`: Whether asset can be borrowed 
    /// - `is_isolated`: Whether asset restricted to isolation mode 
    /// - `debt_ceiling_usd`: Maximum USD debt against isolated collateral 
    /// - `flash_loan_fee`: Flash loan fee percentage (basis points) 
    /// - `is_siloed`: Whether borrowing prevents other asset borrows 
    /// - `flashloan_enabled`: Whether flash loans are supported 
    /// - `can_borrow_in_isolation`: Whether other assets borrowable in isolation 
    /// - `asset_decimals`: Token decimal precision 
    /// - `borrow_cap`: Maximum total borrows (0 = unlimited) 
    /// - `supply_cap`: Maximum total supply (0 = unlimited) 
    ///  
    /// # Returns 
    /// Address of the newly deployed liquidity pool contract 
    ///  
    /// # Errors 
    /// - `ERROR_ASSET_ALREADY_SUPPORTED`: Asset already has an active pool 
    /// - `ERROR_INVALID_TICKER`: Invalid asset identifier format 
    /// - `ERROR_INVALID_LIQUIDATION_THRESHOLD`: Threshold not greater than LTV 
    pub fn create_liquidity_pool<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
        Arg9: ProxyArg<BigUint<Env::Api>>,
        Arg10: ProxyArg<BigUint<Env::Api>>,
        Arg11: ProxyArg<BigUint<Env::Api>>,
        Arg12: ProxyArg<BigUint<Env::Api>>,
        Arg13: ProxyArg<bool>,
        Arg14: ProxyArg<bool>,
        Arg15: ProxyArg<bool>,
        Arg16: ProxyArg<BigUint<Env::Api>>,
        Arg17: ProxyArg<BigUint<Env::Api>>,
        Arg18: ProxyArg<bool>,
        Arg19: ProxyArg<bool>,
        Arg20: ProxyArg<bool>,
        Arg21: ProxyArg<usize>,
        Arg22: ProxyArg<BigUint<Env::Api>>,
        Arg23: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        base_asset: Arg0,
        max_borrow_rate: Arg1,
        base_borrow_rate: Arg2,
        slope1: Arg3,
        slope2: Arg4,
        slope3: Arg5,
        mid_utilization: Arg6,
        optimal_utilization: Arg7,
        reserve_factor: Arg8,
        ltv: Arg9,
        liquidation_threshold: Arg10,
        liquidation_base_bonus: Arg11,
        liquidation_max_fee: Arg12,
        can_be_collateral: Arg13,
        can_be_borrowed: Arg14,
        is_isolated: Arg15,
        debt_ceiling_usd: Arg16,
        flash_loan_fee: Arg17,
        is_siloed: Arg18,
        flashloan_enabled: Arg19,
        can_borrow_in_isolation: Arg20,
        asset_decimals: Arg21,
        borrow_cap: Arg22,
        supply_cap: Arg23,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createLiquidityPool")
            .argument(&base_asset)
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_base_bonus)
            .argument(&liquidation_max_fee)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .argument(&is_isolated)
            .argument(&debt_ceiling_usd)
            .argument(&flash_loan_fee)
            .argument(&is_siloed)
            .argument(&flashloan_enabled)
            .argument(&can_borrow_in_isolation)
            .argument(&asset_decimals)
            .argument(&borrow_cap)
            .argument(&supply_cap)
            .original_result()
    }

    /// Upgrades an existing liquidity pool with new parameters. 
    /// Adjusts interest rate model and reserve settings. 
    ///  
    /// # Arguments 
    /// - `base_asset`: Token identifier (EGLD or ESDT) of the asset. 
    /// - `max_borrow_rate`: New maximum borrow rate. 
    /// - `base_borrow_rate`: New base borrow rate. 
    /// - `slope1`, `slope2`, `slope3`: New interest rate slopes. 
    /// - `mid_utilization`, `optimal_utilization`: New utilization thresholds. 
    /// - `reserve_factor`: New reserve factor. 
    ///  
    /// # Errors 
    /// - `ERROR_NO_POOL_FOUND`: If no pool exists for the asset. 
    pub fn upgrade_liquidity_pool<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        base_asset: Arg0,
        max_borrow_rate: Arg1,
        base_borrow_rate: Arg2,
        slope1: Arg3,
        slope2: Arg4,
        slope3: Arg5,
        mid_utilization: Arg6,
        optimal_utilization: Arg7,
        reserve_factor: Arg8,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("upgradeLiquidityPool")
            .argument(&base_asset)
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .original_result()
    }

    /// Collects protocol revenue from liquidity pools and routes to accumulator. 
    ///  
    /// **Purpose**: Harvests accumulated protocol fees and interest spreads from 
    /// multiple liquidity pools in a single transaction for gas efficiency. 
    /// Routes collected revenue to the accumulator for proper distribution. 
    ///  
    /// **How it works**: 
    /// 1. **Initialization**: Creates cache and validates accumulator address exists 
    /// 2. **Multi-asset iteration**: Processes each specified asset sequentially 
    /// 3. **Revenue claiming**: Calls each pool's claim_revenue with latest price 
    /// 4. **Revenue routing**: Deposits non-zero revenue into accumulator contract 
    /// 5. **Gas optimization**: Batches multiple claims in single transaction 
    ///  
    /// **Revenue sources collected**: 
    /// - **Interest rate spread**: Difference between borrow and supply rates 
    /// - **Reserve factor**: Percentage of interest reserved for protocol 
    /// - **Liquidation fees**: Fees collected during position liquidations 
    /// - **Flash loan fees**: Fees from flash loan operations 
    ///  
    /// **Price-aware collection**: 
    /// Passes latest oracle price to each pool for accurate revenue calculation: 
    /// ``` 
    /// revenue_value = pool_balance * latest_price 
    /// revenue_amount = calculate_claimable_amount(revenue_value) 
    /// ``` 
    ///  
    /// **Zero-revenue optimization**: 
    /// Only deposits revenue into accumulator if amount > 0, preventing 
    /// unnecessary transactions and gas costs for pools with no accrued revenue. 
    ///  
    /// **Multi-asset efficiency**: 
    /// - Single transaction processes multiple assets 
    /// - Cached price feeds reduce oracle query costs 
    /// - Batched accumulator deposits minimize transaction overhead 
    /// - Early termination for zero-revenue assets 
    ///  
    /// **Security considerations**: 
    /// - Owner-only access ensures governance control over revenue collection 
    /// - Accumulator address validation prevents revenue loss 
    /// - Latest price usage prevents stale price manipulation 
    /// - Cache consistency ensures accurate revenue calculations 
    ///  
    /// **Revenue flow pattern**: 
    /// ``` 
    /// 1. Liquidity pools accumulate fees over time 
    /// 2. Governance calls claim_revenue with asset list 
    /// 3. Each pool calculates claimable revenue amount 
    /// 4. Revenue transferred from pools to accumulator 
    /// 5. Accumulator handles distribution per protocol rules 
    /// ``` 
    ///  
    /// **Governance considerations**: 
    /// Regular revenue collection ensures protocol sustainability and proper 
    /// fee distribution to stakeholders. Frequency affects gas costs vs revenue timing. 
    ///  
    /// # Arguments 
    /// - `assets`: Collection of token identifiers to claim revenue from 
    ///  
    /// # Returns 
    /// Nothing - transfers revenue from pools to accumulator 
    ///  
    /// # Errors 
    /// - `ERROR_NO_ACCUMULATOR_FOUND`: Accumulator address not configured 
    pub fn claim_revenue<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRevenue")
            .argument(&assets)
            .original_result()
    }

    /// Registers a new NFT token for tracking account positions in the lending protocol. 
    ///  
    /// **Purpose**: Creates a dynamic NFT collection used to represent user positions 
    /// as transferable tokens. Each NFT contains position data including deposits, 
    /// borrows, and risk parameters. 
    ///  
    /// **How it works**: 
    /// 1. Issues a new ESDT token with DynamicNFT properties 
    /// 2. Sets all necessary roles for minting/burning position NFTs 
    /// 3. Enables position tracking and transferability 
    ///  
    /// **Security checks**: 
    /// - Only contract owner can register account tokens 
    /// - Requires EGLD payment for token issuance (protocol fee) 
    /// - Validates token name and ticker parameters 
    ///  
    /// **Governance considerations**: 
    /// This is a one-time setup function that establishes the position tracking 
    /// mechanism. Once set, users can mint position NFTs representing their 
    /// lending/borrowing activities. 
    ///  
    /// # Arguments 
    /// - `token_name`: Human-readable name for the position NFT collection 
    /// - `ticker`: Short ticker symbol for the NFT collection 
    ///  
    /// # Returns 
    /// Nothing - sets up the account token for future position minting 
    ///  
    /// # Payment Required 
    /// - EGLD payment for ESDT token issuance (amount determined by protocol) 
    pub fn register_account_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        token_name: Arg0,
        ticker: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("registerAccountToken")
            .argument(&token_name)
            .argument(&ticker)
            .original_result()
    }

    /// Configures the oracle for a token’s price feed. 
    /// Sets up pricing method, source, and tolerances. 
    ///  
    /// # Arguments 
    /// - `market_token`: Token identifier (EGLD or ESDT). 
    /// - `decimals`: Decimal precision for the price. 
    /// - `contract_address`: Address of the oracle contract. 
    /// - `pricing_method`: Method for price determination (e.g., Safe, Aggregator). 
    /// - `token_type`: Oracle type (e.g., Normal, Derived). 
    /// - `source`: Exchange source (e.g., XExchange). 
    /// - `first_tolerance`, `last_tolerance`: Tolerance values for price fluctuations. 
    ///  
    /// # Errors 
    /// - `ERROR_ORACLE_TOKEN_NOT_FOUND`: If oracle already exists for the token. 
    pub fn set_token_oracle<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<common_structs::PricingMethod>,
        Arg4: ProxyArg<common_structs::OracleType>,
        Arg5: ProxyArg<common_structs::ExchangeSource>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<u64>,
        Arg9: ProxyArg<OptionalValue<usize>>,
    >(
        self,
        market_token: Arg0,
        decimals: Arg1,
        contract_address: Arg2,
        pricing_method: Arg3,
        token_type: Arg4,
        source: Arg5,
        first_tolerance: Arg6,
        last_tolerance: Arg7,
        max_price_stale_seconds: Arg8,
        one_dex_pair_id: Arg9,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTokenOracle")
            .argument(&market_token)
            .argument(&decimals)
            .argument(&contract_address)
            .argument(&pricing_method)
            .argument(&token_type)
            .argument(&source)
            .argument(&first_tolerance)
            .argument(&last_tolerance)
            .argument(&max_price_stale_seconds)
            .argument(&one_dex_pair_id)
            .original_result()
    }

    /// Updates the tolerance settings for a token’s oracle. 
    /// Adjusts acceptable price deviation ranges. 
    ///  
    /// # Arguments 
    /// - `market_token`: Token identifier (EGLD or ESDT). 
    /// - `first_tolerance`, `last_tolerance`: New tolerance values. 
    ///  
    /// # Errors 
    /// - `ERROR_ORACLE_TOKEN_NOT_FOUND`: If no oracle exists for the token. 
    pub fn edit_token_oracle_tolerance<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        market_token: Arg0,
        first_tolerance: Arg1,
        last_tolerance: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editTokenOracleTolerance")
            .argument(&market_token)
            .argument(&first_tolerance)
            .argument(&last_tolerance)
            .original_result()
    }

    /// Sets the price aggregator contract address. 
    /// Configures the source for aggregated price data. 
    ///  
    /// # Arguments 
    /// - `aggregator`: Address of the price aggregator contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_AGGREGATOR`: If address is zero or not a smart contract. 
    pub fn set_aggregator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        aggregator: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAggregator")
            .argument(&aggregator)
            .original_result()
    }

    /// Sets the Swap Router contract address. 
    /// Configures the source for Swap Router price data. 
    ///  
    /// # Arguments 
    /// - `address`: Address of the Swap Router contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_AGGREGATOR`: If address is zero or not a smart contract. 
    pub fn set_swap_router<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSwapRouter")
            .argument(&address)
            .original_result()
    }

    /// Sets the accumulator contract address. 
    /// Configures where protocol revenue is collected. 
    ///  
    /// # Arguments 
    /// - `accumulator`: Address of the accumulator contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_AGGREGATOR`: If address is zero or not a smart contract. 
    pub fn set_accumulator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        accumulator: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAccumulator")
            .argument(&accumulator)
            .original_result()
    }

    /// Sets the safe price view contract address. 
    /// Configures the source for safe price data in liquidation checks. 
    ///  
    /// # Arguments 
    /// - `safe_view_address`: Address of the safe price view contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_AGGREGATOR`: If address is zero or not a smart contract. 
    pub fn set_safe_price_view<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        safe_view_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSafePriceView")
            .argument(&safe_view_address)
            .original_result()
    }

    /// Sets the template address for liquidity pools. 
    /// Used for deploying new pools with a standard template. 
    ///  
    /// # Arguments 
    /// - `address`: Address of the liquidity pool template contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_LIQUIDITY_POOL_TEMPLATE`: If address is zero or not a smart contract. 
    pub fn set_liquidity_pool_template<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidityPoolTemplate")
            .argument(&address)
            .original_result()
    }

    /// Creates a new efficiency mode (e-mode) category with optimized risk parameters. 
    ///  
    /// **Purpose**: E-mode categories allow users to achieve higher capital efficiency 
    /// when using correlated assets (e.g., different stablecoins or ETH derivatives). 
    /// Categories group assets with similar risk profiles for optimized lending terms. 
    ///  
    /// **How it works**: 
    /// 1. Increments the global e-mode category counter 
    /// 2. Converts risk parameters from basis points to decimal representation 
    /// 3. Creates EModeCategory struct with new ID and parameters 
    /// 4. Stores the category and emits configuration event 
    ///  
    /// **Risk parameter conversion**: 
    /// All parameters are converted using `to_decimal_bps()` formula: 
    /// ``` 
    /// decimal_value = bps_value / 10000 
    /// ``` 
    /// This converts basis points (1 bps = 0.01%) to decimal representation. 
    ///  
    /// **E-mode benefits**: 
    /// - Higher LTV ratios for correlated assets 
    /// - Lower liquidation thresholds (safer for protocol) 
    /// - Optimized capital utilization for users 
    /// - Reduced risk through asset correlation 
    ///  
    /// **Security considerations**: 
    /// - Only owner can create e-mode categories (governance control) 
    /// - Risk parameters must be carefully calibrated for asset correlations 
    /// - Categories cannot be deleted, only deprecated 
    /// - Assets must be explicitly added to categories after creation 
    ///  
    /// **Governance impact**: 
    /// E-mode categories affect user capital efficiency and protocol risk. 
    /// Parameters should reflect actual asset correlations and market conditions. 
    ///  
    /// # Arguments 
    /// - `ltv`: Loan-to-value ratio in basis points (e.g., 8000 = 80%) 
    /// - `liquidation_threshold`: Liquidation threshold in basis points (e.g., 8500 = 85%) 
    /// - `liquidation_bonus`: Liquidation bonus in basis points (e.g., 500 = 5%) 
    ///  
    /// # Returns 
    /// Nothing - creates new e-mode category with auto-assigned ID 
    ///  
    /// # Mathematical formulas 
    /// - **LTV**: Maximum borrowing capacity = collateral_value * ltv 
    /// - **Liquidation threshold**: Position becomes liquidatable when health_factor < 1 
    ///   where health_factor = (collateral * threshold) / debt 
    /// - **Liquidation bonus**: Additional reward for liquidators = liquidated_amount * bonus 
    pub fn add_e_mode_category<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ltv: Arg0,
        liquidation_threshold: Arg1,
        liquidation_bonus: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addEModeCategory")
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_bonus)
            .original_result()
    }

    /// Edits an existing e-mode category’s parameters. 
    /// Updates risk settings for the category. 
    ///  
    /// # Arguments 
    /// - `category`: The updated `EModeCategory` struct. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    pub fn edit_e_mode_category<
        Arg0: ProxyArg<common_structs::EModeCategory<Env::Api>>,
    >(
        self,
        category: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editEModeCategory")
            .argument(&category)
            .original_result()
    }

    /// Removes an e-mode category by marking it as deprecated. 
    /// Disables the category for new positions. 
    ///  
    /// # Arguments 
    /// - `category_id`: ID of the e-mode category to remove. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    pub fn remove_e_mode_category<
        Arg0: ProxyArg<u8>,
    >(
        self,
        category_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeEModeCategory")
            .argument(&category_id)
            .original_result()
    }

    /// Adds an asset to an e-mode category with usage flags. 
    /// Configures collateral and borrowability in e-mode. 
    ///  
    /// # Arguments 
    /// - `asset`: Token identifier (EGLD or ESDT). 
    /// - `category_id`: E-mode category ID. 
    /// - `can_be_collateral`: Flag for collateral usability. 
    /// - `can_be_borrowed`: Flag for borrowability. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    /// - `ERROR_ASSET_NOT_SUPPORTED`: If the asset has no pool. 
    /// - `ERROR_ASSET_ALREADY_SUPPORTED_IN_EMODE`: If the asset is already in the category. 
    pub fn add_asset_to_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<bool>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
        can_be_collateral: Arg2,
        can_be_borrowed: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAssetToEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .original_result()
    }

    /// Edits an asset’s configuration within an e-mode category. 
    /// Updates usage flags for collateral or borrowing. 
    ///  
    /// # Arguments 
    /// - `asset`: Token identifier (EGLD or ESDT). 
    /// - `category_id`: E-mode category ID. 
    /// - `config`: New `EModeAssetConfig` settings. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    /// - `ERROR_ASSET_NOT_SUPPORTED_IN_EMODE`: If the asset is not in the category. 
    pub fn edit_asset_in_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<common_structs::EModeAssetConfig>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
        config: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editAssetInEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .argument(&config)
            .original_result()
    }

    /// Removes an asset from an e-mode category. 
    /// Disables the asset’s e-mode capabilities for the category. 
    ///  
    /// # Arguments 
    /// - `asset`: Token identifier (EGLD or ESDT). 
    /// - `category_id`: E-mode category ID. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    /// - `ERROR_ASSET_NOT_SUPPORTED`: If the asset has no pool. 
    /// - `ERROR_ASSET_NOT_SUPPORTED_IN_EMODE`: If the asset is not in the category. 
    pub fn remove_asset_from_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAssetFromEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .original_result()
    }

    /// Edits an asset’s configuration in the protocol. 
    /// Updates risk parameters, usage flags, and caps. 
    ///  
    /// # Arguments 
    /// - `asset`: Token identifier (EGLD or ESDT). 
    /// - `loan_to_value`: New LTV in BPS. 
    /// - `liquidation_threshold`: New liquidation threshold in BPS. 
    /// - `liquidation_bonus`: New liquidation bonus in BPS. 
    /// - `liquidation_fees`: New liquidation fees in BPS. 
    /// - `is_isolated_asset`: Flag for isolated asset status. 
    /// - `isolation_debt_ceiling_usd`: Debt ceiling for isolated assets in USD. 
    /// - `is_siloed_borrowing`: Flag for siloed borrowing. 
    /// - `is_flashloanable`: Flag for flash loan support. 
    /// - `flashloan_fee`: Flash loan fee in BPS. 
    /// - `is_collateralizable`: Flag for collateral usability. 
    /// - `is_borrowable`: Flag for borrowability. 
    /// - `isolation_borrow_enabled`: Flag for borrowing in isolation mode. 
    /// - `borrow_cap`: New borrow cap (zero for no cap). 
    /// - `supply_cap`: New supply cap (zero for no cap). 
    ///  
    /// # Errors 
    /// - `ERROR_ASSET_NOT_SUPPORTED`: If the asset has no pool or config. 
    /// - `ERROR_INVALID_LIQUIDATION_THRESHOLD`: If threshold is not greater than LTV. 
    pub fn edit_asset_config<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<bool>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<bool>,
        Arg8: ProxyArg<bool>,
        Arg9: ProxyArg<BigUint<Env::Api>>,
        Arg10: ProxyArg<bool>,
        Arg11: ProxyArg<bool>,
        Arg12: ProxyArg<bool>,
        Arg13: ProxyArg<BigUint<Env::Api>>,
        Arg14: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        asset: Arg0,
        loan_to_value: Arg1,
        liquidation_threshold: Arg2,
        liquidation_bonus: Arg3,
        liquidation_fees: Arg4,
        is_isolated_asset: Arg5,
        isolation_debt_ceiling_usd: Arg6,
        is_siloed_borrowing: Arg7,
        is_flashloanable: Arg8,
        flashloan_fee: Arg9,
        is_collateralizable: Arg10,
        is_borrowable: Arg11,
        isolation_borrow_enabled: Arg12,
        borrow_cap: Arg13,
        supply_cap: Arg14,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editAssetConfig")
            .argument(&asset)
            .argument(&loan_to_value)
            .argument(&liquidation_threshold)
            .argument(&liquidation_bonus)
            .argument(&liquidation_fees)
            .argument(&is_isolated_asset)
            .argument(&isolation_debt_ceiling_usd)
            .argument(&is_siloed_borrowing)
            .argument(&is_flashloanable)
            .argument(&flashloan_fee)
            .argument(&is_collateralizable)
            .argument(&is_borrowable)
            .argument(&isolation_borrow_enabled)
            .argument(&borrow_cap)
            .argument(&supply_cap)
            .original_result()
    }

    /// Sets the position limits for NFT accounts. 
    /// Configures maximum number of borrow and supply positions per NFT. 
    ///  
    /// **Purpose**: Controls the maximum number of positions an NFT can hold to optimize 
    /// gas costs during liquidations and prevent excessive complexity in position management. 
    ///  
    /// **Gas Optimization**: By limiting positions per NFT, liquidation operations remain 
    /// within reasonable gas limits, preventing failed liquidations due to gas constraints. 
    ///  
    /// **Default Configuration**: 10 borrow positions + 10 supply positions = 20 total positions 
    ///  
    /// # Arguments 
    /// - `max_borrow_positions`: Maximum number of borrow positions per NFT 
    /// - `max_supply_positions`: Maximum number of supply positions per NFT   
    ///  
    /// # Security 
    /// - Only contract owner can modify position limits 
    /// - Changes affect new positions only, existing positions remain valid 
    /// - Limits are enforced in supply and borrow operations 
    pub fn set_position_limits<
        Arg0: ProxyArg<u8>,
        Arg1: ProxyArg<u8>,
    >(
        self,
        max_borrow_positions: Arg0,
        max_supply_positions: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPositionLimits")
            .argument(&max_borrow_positions)
            .argument(&max_supply_positions)
            .original_result()
    }

    /// Get the set of allowed pools 
    /// This storage mapper holds the addresses of pools that are allowed to participate in the lending protocol. 
    pub fn pools(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPools")
            .original_result()
    }

    /// Get the account token 
    /// This storage mapper holds the logic of the account token, which is a non-fungible token (NFT). 
    pub fn account(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccount")
            .original_result()
    }

    /// Get the account nonce 
    /// This storage mapper holds the nonce of the account, which is a non-fungible token (NFT). 
    pub fn account_nonce(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountNonce")
            .original_result()
    }

    /// Get the account positions 
    /// This storage mapper holds a list of account positions as a set. A position represents a nonce of an account (NFT nonce). 
    pub fn accounts(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccounts")
            .original_result()
    }

    /// Get the account attributes 
    /// This storage mapper maps each minted NFT to account attributes, useful for retrieving attributes without having the NFT in hand. 
    pub fn account_attributes<
        Arg0: ProxyArg<u64>,
    >(
        self,
        nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountAttributes<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountAttributes")
            .argument(&nonce)
            .original_result()
    }

    /// Get the deposit positions 
    /// This storage mapper maps each deposit position to an account nonce, holding a list of assets and their corresponding structs. 
    pub fn positions<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<common_structs::AccountPositionType>,
    >(
        self,
        nonce: Arg0,
        position_type: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPositions")
            .argument(&nonce)
            .argument(&position_type)
            .original_result()
    }

    /// Get the liquidity pool template address 
    /// This storage mapper holds the address of the liquidity pool template, used to create new liquidity pools. 
    pub fn liq_pool_template_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiqPoolTemplateAddress")
            .original_result()
    }

    /// Get the accumulator address 
    /// This storage mapper holds the address of the accumulator, used to claim revenue from the liquidity pools. 
    pub fn accumulator_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccumulatorAddress")
            .original_result()
    }

    /// Get the pools map 
    /// This storage mapper holds a map of pools, used to get the address of a pool given a token ID. 
    pub fn pools_map<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolAddress")
            .argument(&asset)
            .original_result()
    }

    /// Get the price aggregator address 
    /// This storage mapper holds the address of the price aggregator, used to get the price of a token in USD. 
    pub fn price_aggregator_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceAggregatorAddress")
            .original_result()
    }

    /// Get the safe price view address 
    /// This storage mapper holds the address of the safe price view, used to get the price of a token out of the DEX pair. 
    pub fn safe_price_view(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePriceAddress")
            .original_result()
    }

    /// This storage mapper holds the address of the wrapper, used to convert between EGLD <-> WEGLD 
    pub fn wegld_wrapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEGLDWrapperAddress")
            .original_result()
    }

    pub fn swap_router(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSwapRouterAddress")
            .original_result()
    }

    /// Get the asset config 
    /// This storage mapper holds the configuration of an asset, used to retrieve the config of an asset. 
    pub fn asset_config<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AssetConfig<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAssetConfig")
            .argument(&asset)
            .original_result()
    }

    /// Get the last e-mode category ID 
    /// This storage mapper holds the ID of the last e-mode category, used to retrieve the last e-mode category. 
    pub fn last_e_mode_category_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("lastEModeCategoryId")
            .original_result()
    }

    /// Get all e-mode categories 
    /// This storage mapper holds a map of e-mode categories, used to group assets into categories with different risk parameters. 
    pub fn e_mode_category(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<u8, common_structs::EModeCategory<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEModes")
            .original_result()
    }

    /// Get the e-mode categories for a given asset 
    /// This storage mapper holds a set of e-mode categories for a given asset. One asset can have multiple e-mode categories. 
    pub fn asset_e_modes<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u8>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAssetEModes")
            .argument(&asset)
            .original_result()
    }

    /// Get all assets for a given e-mode category 
    /// This storage mapper holds a map of assets for a given e-mode category, used to get the config for a given asset in a given e-mode category. 
    pub fn e_mode_assets<
        Arg0: ProxyArg<u8>,
    >(
        self,
        id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::EModeAssetConfig>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEModesAssets")
            .argument(&id)
            .original_result()
    }

    /// Get the debt in USD for isolated assets 
    /// This storage mapper holds the debt in USD for isolated assets. 
    pub fn isolated_asset_debt_usd<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getIsolatedAssetDebtUsd")
            .argument(&asset)
            .original_result()
    }

    /// Get the token oracle 
    /// This storage mapper holds the oracle of a token, used to get the price of a token. 
    pub fn token_oracle<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::OracleProvider<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenOracle")
            .argument(&asset)
            .original_result()
    }

    pub fn flash_loan_ongoing(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isFlashLoanOngoing")
            .original_result()
    }

    /// Get the position limits configuration 
    /// This storage mapper holds the maximum number of borrow and supply positions per NFT 
    /// Used to optimize gas costs during liquidations and prevent excessive position complexity 
    pub fn position_limits(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::PositionLimits> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPositionLimits")
            .original_result()
    }

    pub fn liquidation_estimations<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<ManagedVec<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>>,
    >(
        self,
        account_nonce: Arg0,
        debt_payments: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (ManagedVec<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>, ManagedVec<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>, ManagedVec<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("liquidationEstimations")
            .argument(&account_nonce)
            .argument(&debt_payments)
            .original_result()
    }

    pub fn get_all_market_indexes<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, common_structs::MarketIndexView<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllMarketIndexes")
            .argument(&assets)
            .original_result()
    }

    /// Retrieves extended configuration views for multiple assets. 
    /// Includes market addresses and current prices in EGLD and USD. 
    ///  
    /// # Arguments 
    /// - `assets`: List of token identifiers (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - Vector of `AssetExtendedConfigView` structs for each asset. 
    pub fn get_all_markets<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, common_structs::AssetExtendedConfigView<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllMarkets")
            .argument(&assets)
            .original_result()
    }

    /// Determines if an account position is eligible for liquidation. 
    /// Checks if the health factor is below 1 (100% in WAD precision). 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - `bool`: `true` if the position can be liquidated. 
    pub fn can_be_liquidated<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("canBeLiquidated")
            .argument(&account_nonce)
            .original_result()
    }

    /// Computes the current health factor for an account position. 
    /// Indicates position safety; lower values increase liquidation risk. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - Health factor as a `ManagedDecimal` in WAD precision. 
    pub fn get_health_factor<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHealthFactor")
            .argument(&account_nonce)
            .original_result()
    }

    /// Retrieves the collateral amount for a specific token in an account position. 
    /// Fails if the token is not part of the position’s collateral. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    /// - `token_id`: Token identifier (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - Collateral amount as a `ManagedDecimal`. 
    ///  
    /// # Panics 
    /// - If the token is not in the account’s collateral. 
    pub fn get_collateral_amount_for_token<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account_nonce: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralAmountForToken")
            .argument(&account_nonce)
            .argument(&token_id)
            .original_result()
    }

    /// Retrieves the borrowed amount for a specific token in an account position. 
    /// Fails if the token is not part of the position’s borrows. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    /// - `token_id`: Token identifier (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - Borrowed amount as a `ManagedDecimal`. 
    ///  
    /// # Panics 
    /// - If the token is not in the account’s borrows. 
    pub fn get_borrow_amount_for_token<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account_nonce: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowAmountForToken")
            .argument(&account_nonce)
            .argument(&token_id)
            .original_result()
    }

    /// Computes the total borrow value in EGLD for an account position. 
    /// Sums the EGLD value of all borrowed assets. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - Total borrow value in EGLD as a `ManagedDecimal`. 
    pub fn get_total_borrow_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrowInEgld")
            .argument(&account_nonce)
            .original_result()
    }

    /// Computes the total collateral value in EGLD for an account position. 
    /// Sums the EGLD value of all collateral assets (unweighted). 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - Total collateral value in EGLD as a `ManagedDecimal`. 
    pub fn get_total_collateral_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalCollateralInEgld")
            .argument(&account_nonce)
            .original_result()
    }

    /// Computes the liquidation collateral available in EGLD. 
    /// Represents collateral value weighted by liquidation thresholds. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - Liquidation collateral in EGLD as a `ManagedDecimal`. 
    pub fn get_liquidation_collateral_available<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationCollateralAvailable")
            .argument(&account_nonce)
            .original_result()
    }

    /// Computes the LTV-weighted collateral value in EGLD. 
    /// Represents collateral value weighted by loan-to-value ratios. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - LTV-weighted collateral in EGLD as a `ManagedDecimal`. 
    pub fn get_ltv_collateral_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLtvCollateralInEgld")
            .argument(&account_nonce)
            .original_result()
    }

    /// Retrieves the USD price of a token using oracle data. 
    /// Converts the token’s EGLD price to USD for standardization. 
    ///  
    /// # Arguments 
    /// - `token_id`: Token identifier (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - USD price of the token as a `ManagedDecimal`. 
    pub fn get_usd_price<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenPriceUSD")
            .argument(&token_id)
            .original_result()
    }

    /// Retrieves the EGLD price of a token using oracle data. 
    /// Accesses the token’s price feed directly. 
    ///  
    /// # Arguments 
    /// - `token_id`: Token identifier (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - EGLD price of the token as a `ManagedDecimal`. 
    pub fn get_egld_price<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenPriceEGLD")
            .argument(&token_id)
            .original_result()
    }

    /// **MULTIPLY STRATEGY: Flash Loan Leverage Position Creation** 
    ///  
    /// # Purpose and Scope 
    /// Creates leveraged positions by borrowing debt tokens via flash loan, swapping them to collateral tokens, 
    /// and depositing the collateral to create or enhance an existing position. This strategy allows users to 
    /// increase their exposure to an asset without having the full collateral amount upfront. 
    ///  
    /// # Methodology and Process 
    /// 1. **Flash Loan Initiation**: Borrows `debt_to_flash_loan` amount of debt tokens from liquidity layer 
    /// 2. **Token Conversion**: Swaps the borrowed debt tokens to collateral tokens using the swap router 
    /// 3. **Collateral Supply**: Deposits the received collateral tokens to the lending pool 
    /// 4. **Position Management**: Creates or updates the user's position with new collateral and debt 
    /// 5. **Health Validation**: Ensures the final position maintains healthy collateralization ratio 
    ///  
    /// # Mathematical Formula 
    /// Final Leverage = (Initial Collateral + Borrowed Amount * Swap Rate) / Initial Collateral 
    /// Health Factor = (Collateral Value * Liquidation Threshold) / Total Debt Value 
    /// Where Health Factor must be > 1.0 for position safety 
    ///  
    /// # Security Checks Implemented 
    /// - **Reentrancy Protection**: Guards against flash loan reentrancy attacks 
    /// - **Token Validation**: Ensures collateral and debt tokens are different assets 
    /// - **Payment Validation**: Validates initial payment amounts and token types 
    /// - **Position Mode Validation**: Ensures position is in leverage mode (not Normal/None) 
    /// - **Health Factor Validation**: Verifies position remains healthy after leverage 
    /// - **Asset Configuration**: Validates both tokens are properly configured in the protocol 
    /// - **E-Mode Compatibility**: Ensures tokens are compatible with efficiency mode if specified 
    ///  
    /// # Arguments 
    /// - `e_mode_category`: Efficiency mode category for correlated assets (0 for disabled) 
    /// - `collateral_token`: Token to be used as collateral after swap 
    /// - `debt_to_flash_loan`: Amount of debt token to borrow via flash loan 
    /// - `debt_token`: Token to be borrowed and swapped to collateral 
    /// - `mode`: Position mode (must be leverage-compatible, not Normal/None) 
    /// - `steps`: Swap router steps for debt token to collateral token conversion 
    /// - `steps_payment`: Optional swap steps if initial payment needs conversion 
    ///  
    /// # Returns 
    /// - Creates or updates leveraged position with increased collateral and debt 
    /// - Emits position creation/update events through the lending protocol 
    ///  
    /// # Risk Considerations 
    /// - High slippage during swaps can reduce effective leverage and affect health factor 
    /// - Flash loan failure will revert entire transaction, protecting user funds 
    /// - Position becomes liquidatable if collateral value drops significantly 
    pub fn multiply<
        Arg0: ProxyArg<u8>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg4: ProxyArg<common_structs::PositionMode>,
        Arg5: ProxyArg<ManagedArgBuffer<Env::Api>>,
        Arg6: ProxyArg<OptionalValue<ManagedArgBuffer<Env::Api>>>,
    >(
        self,
        e_mode_category: Arg0,
        collateral_token: Arg1,
        debt_to_flash_loan: Arg2,
        debt_token: Arg3,
        mode: Arg4,
        steps: Arg5,
        steps_payment: Arg6,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("multiply")
            .argument(&e_mode_category)
            .argument(&collateral_token)
            .argument(&debt_to_flash_loan)
            .argument(&debt_token)
            .argument(&mode)
            .argument(&steps)
            .argument(&steps_payment)
            .original_result()
    }

    /// **SWAP DEBT STRATEGY: Convert Debt Position Between Different Tokens** 
    ///  
    /// # Purpose and Scope 
    /// Converts existing debt from one token type to another while maintaining the same collateral. 
    /// This strategy allows users to change their debt exposure without affecting their collateral positions, 
    /// useful for interest rate arbitrage, risk management, or taking advantage of better borrowing conditions. 
    ///  
    /// # Methodology and Process 
    /// 1. **Flash Loan Creation**: Borrows the new debt token amount from liquidity layer 
    /// 2. **Token Swap**: Converts new debt tokens to existing debt tokens via swap router 
    /// 3. **Debt Repayment**: Uses swapped tokens plus any provided payments to repay existing debt 
    /// 4. **Position Update**: Updates the debt position to reflect the new debt token type 
    /// 5. **Health Validation**: Ensures position remains healthy after the debt conversion 
    ///  
    /// # Mathematical Formula 
    /// Debt Conversion Rate = (Existing Debt Amount * Existing Token Price) / (New Token Price * (1 - Slippage)) 
    /// New Health Factor = (Total Collateral Value * Liquidation Threshold) / New Debt Value 
    /// Where New Health Factor must remain > 1.0 
    ///  
    /// # Security Checks Implemented 
    /// - **Reentrancy Protection**: Guards against flash loan reentrancy attacks 
    /// - **Token Differentiation**: Ensures existing and new debt tokens are different 
    /// - **Account Validation**: Verifies caller owns the position being modified 
    /// - **Siloed Borrowing Check**: Prevents debt swaps involving siloed (restricted) tokens 
    /// - **Payment Validation**: Validates any additional payments for debt coverage 
    /// - **Health Factor Validation**: Ensures position remains healthy post-swap 
    /// - **Slippage Protection**: Built into swap router to prevent excessive value loss 
    ///  
    /// # Arguments 
    /// - `existing_debt_token`: Current debt token to be repaid and replaced 
    /// - `new_debt_amount_raw`: Amount of new debt token to borrow (raw units) 
    /// - `new_debt_token`: New debt token type to replace existing debt 
    /// - `steps`: Swap router configuration for token conversion path 
    ///  
    /// # Returns 
    /// - Updates debt position with new token type and amount 
    /// - Maintains existing collateral positions unchanged 
    /// - Emits debt swap events through the lending protocol 
    ///  
    /// # Risk Considerations 
    /// - Swap slippage may require additional payments to fully repay existing debt 
    /// - Interest rate changes between tokens affect ongoing borrowing costs 
    /// - Market volatility during swap execution can impact final debt amounts 
    /// - Position may become liquidatable if swap results in higher debt value 
    pub fn swap_debt<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<ManagedArgBuffer<Env::Api>>,
    >(
        self,
        existing_debt_token: Arg0,
        new_debt_amount_raw: Arg1,
        new_debt_token: Arg2,
        steps: Arg3,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("swapDebt")
            .argument(&existing_debt_token)
            .argument(&new_debt_amount_raw)
            .argument(&new_debt_token)
            .argument(&steps)
            .original_result()
    }

    /// **SWAP COLLATERAL STRATEGY: Convert Collateral Between Different Token Types** 
    ///  
    /// # Purpose and Scope 
    /// Converts existing collateral from one token type to another while maintaining the same debt positions. 
    /// This strategy enables portfolio rebalancing, risk management, and optimization of collateral efficiency 
    /// without affecting existing borrowing positions. 
    ///  
    /// # Methodology and Process 
    /// 1. **Collateral Withdrawal**: Withdraws specified amount of current collateral from the position 
    /// 2. **Token Conversion**: Swaps the withdrawn collateral to the new collateral token via swap router 
    /// 3. **Collateral Redeposit**: Deposits the converted tokens back as new collateral 
    /// 4. **Position Update**: Updates collateral composition while preserving debt positions 
    /// 5. **Health Validation**: Ensures position maintains healthy collateralization after swap 
    ///  
    /// # Mathematical Formula 
    /// Collateral Conversion Rate = (Withdrawn Amount * Current Token Price) / (New Token Price * (1 - Slippage)) 
    /// New Health Factor = (New Collateral Value * New Liquidation Threshold) / Total Debt Value 
    /// Where New Health Factor must remain > 1.0 
    ///  
    /// # Security Checks Implemented 
    /// - **Reentrancy Protection**: Guards against flash loan reentrancy attacks 
    /// - **Account Validation**: Verifies caller owns the position being modified 
    /// - **Isolation Mode Check**: Prevents collateral swaps in isolated asset positions 
    /// - **New Asset Validation**: Ensures target collateral is not an isolated asset 
    /// - **Withdrawal Validation**: Confirms sufficient collateral balance for withdrawal 
    /// - **Health Factor Validation**: Ensures position remains healthy post-swap 
    /// - **Payment Validation**: Validates any additional payments provided 
    ///  
    /// # Arguments 
    /// - `current_collateral`: Existing collateral token to be converted 
    /// - `from_amount`: Amount of current collateral to convert (raw units) 
    /// - `new_collateral`: Target collateral token type 
    /// - `steps`: Swap router configuration for token conversion path 
    ///  
    /// # Returns 
    /// - Updates collateral position with new token type and converted amount 
    /// - Maintains existing debt positions unchanged 
    /// - Emits collateral swap events through the lending protocol 
    ///  
    /// # Risk Considerations 
    /// - Swap slippage reduces effective collateral value and may impact health factor 
    /// - Different liquidation thresholds between tokens affect position safety 
    /// - Market volatility during swap execution can impact final collateral amounts 
    /// - Position may become liquidatable if swap results in insufficient collateral value 
    pub fn swap_collateral<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<ManagedArgBuffer<Env::Api>>,
    >(
        self,
        current_collateral: Arg0,
        from_amount: Arg1,
        new_collateral: Arg2,
        steps: Arg3,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("swapCollateral")
            .argument(&current_collateral)
            .argument(&from_amount)
            .argument(&new_collateral)
            .argument(&steps)
            .original_result()
    }

    /// **REPAY DEBT WITH COLLATERAL STRATEGY: Liquidate Collateral to Repay Debt** 
    ///  
    /// # Purpose and Scope 
    /// Converts collateral assets to debt tokens for automatic debt repayment, enabling users to reduce 
    /// their debt burden without external token sources. This strategy is particularly useful for 
    /// deleveraging positions, managing liquidation risk, or closing positions entirely. 
    ///  
    /// # Methodology and Process 
    /// 1. **Collateral Withdrawal**: Withdraws specified amount of collateral from the user's position 
    /// 2. **Token Conversion**: Swaps withdrawn collateral to debt tokens via swap router 
    /// 3. **Debt Repayment**: Uses converted tokens plus any additional payments to repay outstanding debt 
    /// 4. **Position Closure**: If `close_position` is true and all debt is repaid, withdraws remaining collateral and burns position NFT 
    /// 5. **Health Validation**: Ensures position remains healthy after debt reduction (if not fully closed) 
    ///  
    /// # Mathematical Formula 
    /// Debt Repayment Amount = (Withdrawn Collateral * Collateral Price * (1 - Slippage)) / Debt Token Price 
    /// Remaining Health Factor = (Remaining Collateral Value * Liquidation Threshold) / Remaining Debt Value 
    /// For partial repayment, Remaining Health Factor must be > 1.0 
    ///  
    /// # Security Checks Implemented 
    /// - **Reentrancy Protection**: Guards against flash loan reentrancy attacks 
    /// - **Account Validation**: Verifies caller owns the position being modified 
    /// - **Collateral Sufficiency**: Ensures sufficient collateral balance for withdrawal 
    /// - **Payment Validation**: Validates any additional payments provided for debt coverage 
    /// - **Health Factor Validation**: Ensures position remains healthy after partial repayment 
    /// - **Position Closure Validation**: Verifies all debt is repaid before position closure 
    /// - **Asset Validation**: Confirms both collateral and debt tokens are properly configured 
    ///  
    /// # Arguments 
    /// - `from_token`: Collateral token to be converted for debt repayment 
    /// - `from_amount`: Amount of collateral to withdraw and convert (raw units) 
    /// - `to_token`: Debt token to be repaid with converted collateral 
    /// - `close_position`: Flag to close entire position if all debt is repaid (burns NFT and withdraws remaining collateral) 
    /// - `steps`: Optional swap router configuration for collateral to debt token conversion 
    ///  
    /// # Returns 
    /// - Reduces debt position by the amount repaid through collateral conversion 
    /// - Reduces collateral position by the amount withdrawn for conversion 
    /// - If `close_position` and debt fully repaid: burns position NFT and returns all remaining collateral 
    /// - Emits debt repayment and position update events through the lending protocol 
    ///  
    /// # Risk Considerations 
    /// - Swap slippage may result in insufficient debt tokens to fully repay intended amount 
    /// - Market volatility during conversion affects final repayment effectiveness 
    /// - Position may become liquidatable if remaining collateral is insufficient after partial repayment 
    /// - Closing positions requires complete debt repayment; partial closure is not supported 
    pub fn repay_debt_with_collateral<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<bool>,
        Arg4: ProxyArg<OptionalValue<ManagedArgBuffer<Env::Api>>>,
    >(
        self,
        from_token: Arg0,
        from_amount: Arg1,
        to_token: Arg2,
        close_position: Arg3,
        steps: Arg4,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("repayDebtWithCollateral")
            .argument(&from_token)
            .argument(&from_amount)
            .argument(&to_token)
            .argument(&close_position)
            .argument(&steps)
            .original_result()
    }
}
