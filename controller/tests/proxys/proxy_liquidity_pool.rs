// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LiquidityPoolProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LiquidityPoolProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LiquidityPoolProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LiquidityPoolProxyMethods { wrapped_tx: tx }
    }
}

pub struct LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LiquidityPoolProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the liquidity pool for a specific asset. 
    ///  
    /// **Purpose**: Sets up the initial state of the liquidity pool, including the asset, interest rate parameters, 
    /// supply and borrow indexes, and other key variables, preparing it for lending operations. 
    ///  
    /// **Process**: 
    /// 1. Stores the pool's asset identifier. 
    /// 2. Configures interest rate parameters (`max_borrow_rate`, `base_borrow_rate`, `slope1`, `slope2`, `slope3`, `mid_utilization`, `optimal_utilization`, `reserve_factor`) 
    ///    by converting `BigUint` inputs to `ManagedDecimal` with appropriate scaling (RAY for rates, BPS for reserve factor). 
    /// 3. Initializes the borrow and supply indexes to `RAY` (representing 1.0 in the system's precision). 
    /// 4. Sets initial values for supplied, reserves, borrowed, and revenue to zero, using the asset's decimal precision. 
    /// 5. Records the current blockchain timestamp as the last update time. 
    ///  
    /// ### Parameters 
    /// - `asset`: The asset identifier (`EgldOrEsdtTokenIdentifier`) for the pool. 
    /// - `max_borrow_rate`: Maximum borrow rate (`BigUint`), scaled to RAY precision. 
    /// - `base_borrow_rate`: Base borrow rate (`BigUint`), scaled to RAY precision. 
    /// - `slope1`: Slope before optimal utilization (`BigUint`), scaled to RAY precision. 
    /// - `slope2`: Slope after optimal utilization (`BigUint`), scaled to RAY precision. 
    /// - `slope3`: Slope for high utilization (`BigUint`), scaled to RAY precision. 
    /// - `mid_utilization`: Midpoint utilization ratio (`BigUint`), scaled to RAY precision. 
    /// - `optimal_utilization`: Optimal utilization ratio (`BigUint`), scaled to RAY precision. 
    /// - `reserve_factor`: Fraction of interest reserved as protocol fee (`BigUint`), scaled to BPS precision. 
    /// - `asset_decimals`: Number of asset_decimals for the asset (`usize`). 
    ///  
    /// ### Returns 
    /// - Nothing (void function). 
    ///  
    /// **Security Considerations**: 
    /// - Ensures all critical state variables (asset, parameters, indexes, etc.) are initialized to prevent uninitialized storage vulnerabilities. 
    /// - Uses precise decimal conversions (`to_decimal_ray` and `to_decimal_bps`) to maintain calculation accuracy. 
    pub fn init<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
        Arg9: ProxyArg<usize>,
    >(
        self,
        asset: Arg0,
        max_borrow_rate: Arg1,
        base_borrow_rate: Arg2,
        slope1: Arg3,
        slope2: Arg4,
        slope3: Arg5,
        mid_utilization: Arg6,
        optimal_utilization: Arg7,
        reserve_factor: Arg8,
        asset_decimals: Arg9,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&asset)
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .argument(&asset_decimals)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Upgrades the liquidity pool parameters. 
    ///  
    /// **Purpose**: Updates the pool's interest rate parameters and reserve factor to adapt to changing market conditions 
    /// or protocol requirements, ensuring flexibility in pool management. 
    ///  
    /// **Process**: 
    /// 1. Emits an event (`market_params_event`) with the new parameters for transparency and auditability. 
    /// 2. Updates the existing pool parameters by converting `BigUint` inputs to `ManagedDecimal` with appropriate scaling. 
    ///  
    /// ### Parameters 
    /// - `max_borrow_rate`: New maximum borrow rate (`BigUint`), scaled to RAY precision. 
    /// - `base_borrow_rate`: New base borrow rate (`BigUint`), scaled to RAY precision. 
    /// - `slope1`: New slope before optimal utilization (`BigUint`), scaled to RAY precision. 
    /// - `slope2`: New slope after optimal utilization (`BigUint`), scaled to RAY precision. 
    /// - `slope3`: New slope for high utilization (`BigUint`), scaled to RAY precision. 
    /// - `mid_utilization`: New midpoint utilization ratio (`BigUint`), scaled to RAY precision. 
    /// - `optimal_utilization`: New optimal utilization ratio (`BigUint`), scaled to RAY precision. 
    /// - `reserve_factor`: New fraction of interest reserved as protocol fee (`BigUint`), scaled to BPS precision. 
    /// - `asset_price`: New asset price (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// ### Returns 
    /// - Nothing (void function). 
    ///  
    /// **Security Considerations**: 
    /// - Restricted to the contract owner (via the `#[upgrade]` attribute) to prevent unauthorized modifications. 
    /// - Uses precise decimal conversions (`to_decimal_ray` and `to_decimal_bps`) to ensure consistency in calculations. 
    /// - Logs changes via an event, enabling tracking and verification of updates. 
    pub fn upgrade<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        max_borrow_rate: Arg0,
        base_borrow_rate: Arg1,
        slope1: Arg2,
        slope2: Arg3,
        slope3: Arg4,
        mid_utilization: Arg5,
        optimal_utilization: Arg6,
        reserve_factor: Arg7,
        asset_price: Arg8,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .argument(&asset_price)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Retrieves the total scaled amount supplied to the pool. 
    /// This value represents the sum of all supplied principals, each divided by the supply index at the time of their deposit. 
    /// It is stored RAY-scaled. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The total scaled amount supplied, RAY-scaled. 
    pub fn supplied(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSuppliedScaled")
            .original_result()
    }

    /// Retrieves the protocol revenue accrued from borrow interest fees. 
    /// This value is stored RAY-scaled. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The accumulated protocol revenue, RAY-scaled. 
    pub fn revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRevenueScaled")
            .original_result()
    }

    /// Retrieves the total scaled borrowed amount from the pool. 
    /// This value represents the sum of all borrowed principals, each divided by the borrow index at the time of their borrowing. 
    /// It is stored RAY-scaled. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The total scaled borrowed amount, RAY-scaled. 
    pub fn borrowed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowedScaled")
            .original_result()
    }

    /// Returns the market parameters. 
    ///  
    /// These include interest rate parameters and asset decimals. 
    ///  
    /// # Returns 
    /// - `MarketParams<Self::Api>`: The market configuration. 
    pub fn params(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::MarketParams<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getParams")
            .original_result()
    }

    /// Retrieves the current borrow index. 
    ///  
    /// The borrow index is used to calculate accrued interest on borrow positions. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current borrow index. 
    pub fn borrow_index(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowIndex")
            .original_result()
    }

    /// Retrieves the current supply index. 
    ///  
    /// The supply index is used to compute the yield for suppliers. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current supply index. 
    pub fn supply_index(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSupplyIndex")
            .original_result()
    }

    /// Retrieves the last update timestamp for the interest indexes. 
    ///  
    /// # Returns 
    /// - `u64`: The timestamp when indexes were last updated. 
    pub fn last_timestamp(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastTimestamp")
            .original_result()
    }

    /// Updates the market's borrow and supply indexes based on elapsed time since the last update. 
    ///  
    /// **Purpose**: Ensures the pool's interest calculations reflect the latest state by computing an interest factor based on time elapsed and applying it to the borrow and supply indexes. 
    ///  
    /// **Process**: 
    /// 1. Creates a `Cache` to snapshot the current pool state. 
    /// 2. Calls `global_sync` to update the borrow and supply indexes. 
    /// 3. Emits a market state event to log the updated state. 
    ///  
    /// # Arguments 
    /// - `price`: The current price of the pool asset (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// **Security Considerations**: Restricted to the owner (via controller contract) to ensure controlled updates. 
    pub fn update_indexes<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        price: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::MarketIndex<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateIndexes")
            .argument(&price)
            .original_result()
    }

    /// Supplies assets to the lending pool, increasing reserves and the supplier's position. 
    ///  
    /// **Purpose**: Allows users to deposit assets into the pool to earn interest, increasing available liquidity. 
    ///  
    /// **Process**: 
    /// 1. Retrieves and validates the payment amount using `get_payment_amount`. 
    /// 2. Updates global indexes and the supplier's position with accrued interest. 
    /// 3. Adds the supplied amount to the position, reserves, and total supplied. 
    /// 4. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `position`: The supplier's current position (`AccountPosition<Self::Api>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `AccountPosition<Self::Api>`: The updated position with the new supply amount. 
    ///  
    /// **Security Considerations**: Validates the asset type via `get_payment_amount` to ensure only the pool's asset is supplied. 
    /// Can only be called by the owner (via controller contract). 
    pub fn supply<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        price: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .raw_call("supply")
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Borrows assets from the pool against a user's collateral. 
    ///  
    /// **Purpose**: Enables users to borrow assets, deducting from reserves and increasing their debt. 
    ///  
    /// **Process**: 
    /// 1. Updates global indexes and the borrower's position with accrued interest. 
    /// 2. Verifies sufficient reserves are available. 
    /// 3. Increases the borrower's debt and total borrowed, then deducts from reserves. 
    /// 4. Transfers the borrowed amount to the caller. 
    /// 5. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `initial_caller`: The borrower's address (`ManagedAddress`). 
    /// - `amount`: The amount to borrow (`ManagedDecimal<Self::Api, NumDecimals>`). 
    /// - `position`: The borrower's current position (`AccountPosition<Self::Api>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `AccountPosition<Self::Api>`: The updated borrow position. 
    ///  
    /// **Security Considerations**: Uses `require!` to ensure sufficient liquidity, preventing over-borrowing. 
    /// Can only be called by the owner (via controller contract). 
    pub fn borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg3: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        amount: Arg1,
        position: Arg2,
        price: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrow")
            .argument(&initial_caller)
            .argument(&amount)
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Withdraws assets from the pool, supporting both normal withdrawals and liquidations. 
    ///  
    /// **Purpose**: Enables suppliers to redeem their scaled tokens for underlying assets, 
    /// realizing accumulated interest, or facilitates liquidation of collateral. 
    ///  
    /// **Mathematical Process**: 
    /// 1. **Global Sync**: Update indexes to include latest interest 
    /// 2. **Current Value Calculation**: `current_value = scaled_position * supply_index` 
    /// 3. **Withdrawal Amount Determination**: 
    ///    - Full withdrawal: `amount = min(requested, current_value)` 
    ///    - Partial withdrawal: `amount = requested` 
    /// 4. **Scaling Conversion**: `scaled_to_burn = amount / supply_index` 
    /// 5. **Fee Processing** (if liquidation): `net_amount = gross_amount - liquidation_fee` 
    /// 6. **State Updates**: 
    ///    - `position.scaled_amount -= scaled_to_burn` 
    ///    - `total_supplied -= scaled_to_burn` 
    ///  
    /// **Interest Realization Formula**: 
    /// ``` 
    /// // Interest earned since supply: 
    /// interest = scaled_tokens * (current_supply_index - supply_index_at_deposit) 
    /// total_withdrawal = principal + interest - fees 
    /// ``` 
    ///  
    /// **Liquidation Fee Mechanism**: 
    /// During liquidations, a protocol fee may be deducted: 
    /// ``` 
    /// net_transfer = gross_withdrawal - liquidation_fee 
    /// protocol_revenue += liquidation_fee (scaled) 
    /// ``` 
    ///  
    /// **Reserve Validation**: 
    /// Ensures sufficient contract balance exists for the withdrawal. 
    ///  
    /// # Arguments 
    /// - `initial_caller`: Recipient of withdrawn assets 
    /// - `amount`: Requested withdrawal amount 
    /// - `position`: User's current supply position 
    /// - `is_liquidation`: Flag for liquidation-specific processing 
    /// - `protocol_fee_opt`: Optional liquidation fee to deduct 
    /// - `price`: Asset price for event logging 
    ///  
    /// # Returns 
    /// - Updated position with reduced scaled supply 
    ///  
    /// **Security Considerations**: 
    /// - Amount capping prevents over-withdrawal 
    /// - Reserve validation ensures liquidity availability 
    /// - Fee validation prevents insufficient withdrawal amounts 
    /// - Scaled burning maintains pool integrity 
    pub fn withdraw<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg3: ProxyArg<bool>,
        Arg4: ProxyArg<Option<ManagedDecimal<Env::Api, usize>>>,
        Arg5: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        amount: Arg1,
        position: Arg2,
        is_liquidation: Arg3,
        protocol_fee_opt: Arg4,
        price: Arg5,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdraw")
            .argument(&initial_caller)
            .argument(&amount)
            .argument(&position)
            .argument(&is_liquidation)
            .argument(&protocol_fee_opt)
            .argument(&price)
            .original_result()
    }

    /// Processes a repayment for a borrow position, handling full or partial repayments with overpayment refunds. 
    ///  
    /// **Purpose**: Reduces borrower debt by burning scaled debt tokens proportional to the 
    /// payment amount, automatically handling interest and refunding overpayments. 
    ///  
    /// **Mathematical Process**: 
    /// 1. **Global Sync**: Update borrow index to accrue latest interest 
    /// 2. **Current Debt Calculation**: `current_debt = scaled_debt * current_borrow_index` 
    /// 3. **Repayment Allocation**: 
    ///    - If `payment >= current_debt`: Full repayment + overpayment 
    ///    - If `payment < current_debt`: Partial repayment 
    /// 4. **Scaling Conversion**: 
    ///    - Full: `scaled_to_burn = entire_scaled_position` 
    ///    - Partial: `scaled_to_burn = payment / current_borrow_index` 
    /// 5. **State Updates**: 
    ///    - `position.scaled_amount -= scaled_to_burn` 
    ///    - `total_borrowed -= scaled_to_burn` 
    /// 6. **Overpayment Handling**: `refund = max(0, payment - current_debt)` 
    ///  
    /// **Debt Reduction Formula**: 
    /// ``` 
    /// // Current total debt including interest: 
    /// total_debt = scaled_debt * current_borrow_index 
    ///  
    /// // Proportion of debt being repaid: 
    /// repayment_ratio = min(1, payment_amount / total_debt) 
    /// scaled_to_burn = scaled_debt * repayment_ratio 
    /// ``` 
    ///  
    /// **Interest Payment Mechanism**: 
    /// Interest is automatically included in the debt calculation through 
    /// the borrow index, so borrowers pay accrued interest proportionally. 
    ///  
    /// **Overpayment Protection**: 
    /// Excess payments are automatically refunded to prevent loss of funds: 
    /// ``` 
    /// if payment > total_debt: 
    ///     actual_payment = total_debt 
    ///     refund = payment - total_debt 
    /// ``` 
    ///  
    /// # Arguments 
    /// - `initial_caller`: Address to receive any overpayment refund 
    /// - `position`: User's current borrow position 
    /// - `price`: Asset price for event logging 
    ///  
    /// # Returns 
    /// - Updated position with reduced scaled debt 
    ///  
    /// **Security Considerations**: 
    /// - Asset validation prevents wrong token repayments 
    /// - Overpayment refunds prevent accidental loss 
    /// - Scaled burning maintains precise debt tracking 
    /// - Global sync ensures fair interest calculation 
    pub fn repay<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg2: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        position: Arg1,
        price: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .raw_call("repay")
            .argument(&initial_caller)
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Provides a flash loan from the pool, enabling temporary borrowing without collateral within a single transaction. 
    ///  
    /// **Purpose**: Facilitates atomic operations like arbitrage, liquidations, or complex DeFi strategies 
    /// by providing instant liquidity that must be repaid with fees in the same transaction. 
    ///  
    /// **Mathematical Process**: 
    /// 1. **Liquidity Validation**: Verify `amount <= available_reserves` 
    /// 2. **Fee Calculation**: `required_repayment = amount * (1 + fee_rate)` 
    /// 3. **Asset Transfer**: Send `amount` to target contract 
    /// 4. **External Execution**: Call target contract with provided parameters 
    /// 5. **Repayment Validation**: Ensure `back_transfer >= required_repayment` 
    /// 6. **Protocol Revenue**: `fee = repayment - amount`, add to treasury 
    ///  
    /// **Flash Loan Fee Formula**: 
    /// ``` 
    /// fee_basis_points = fees_parameter  // e.g., 30 = 0.30% 
    /// fee_rate = fee_basis_points / 10000 
    /// required_repayment = loan_amount * (1 + fee_rate) 
    /// protocol_fee = repayment_amount - loan_amount 
    /// ``` 
    ///  
    /// **Atomic Transaction Requirement**: 
    /// The entire flash loan operation must complete in a single transaction: 
    /// ``` 
    /// 1. Borrow assets from pool 
    /// 2. Execute arbitrary logic (arbitrage, liquidation, etc.) 
    /// 3. Repay loan + fees to pool 
    /// 4. Transaction reverts if repayment insufficient 
    /// ``` 
    ///  
    /// **Reentrancy Protection**: 
    /// Cache is dropped before external call to prevent state manipulation: 
    /// ``` 
    /// // State snapshot before external call 
    /// drop(cache); 
    /// // External call execution 
    /// let result = contract.call(); 
    /// // Fresh state validation after call 
    /// validate_repayment(); 
    /// ``` 
    ///  
    /// **Revenue Distribution**: 
    /// Flash loan fees are added directly to protocol treasury as scaled supply tokens. 
    ///  
    /// # Arguments 
    /// - `borrowed_token`: Asset to borrow (must match pool asset) 
    /// - `amount`: Loan amount in asset decimals 
    /// - `contract_address`: Target contract for strategy execution 
    /// - `endpoint`: Function to call on target contract 
    /// - `arguments`: Parameters for the external call 
    /// - `fees`: Fee rate in basis points (e.g., 30 = 0.30%) 
    /// - `price`: Asset price for event logging 
    ///  
    /// **Security Considerations**: 
    /// - Reentrancy protection via cache dropping 
    /// - Asset validation prevents wrong token loans 
    /// - Reserve validation ensures liquidity availability 
    /// - Repayment validation enforces fee collection 
    /// - Atomic execution prevents partial failures 
    pub fn flash_loan<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<ManagedArgBuffer<Env::Api>>,
        Arg5: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg6: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        borrowed_token: Arg0,
        amount: Arg1,
        contract_address: Arg2,
        endpoint: Arg3,
        arguments: Arg4,
        fees: Arg5,
        price: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("flashLoan")
            .argument(&borrowed_token)
            .argument(&amount)
            .argument(&contract_address)
            .argument(&endpoint)
            .argument(&arguments)
            .argument(&fees)
            .argument(&price)
            .original_result()
    }

    /// Creates a leveraged strategy position by borrowing assets with upfront fee collection. 
    ///  
    /// **Purpose**: Enables creation of leveraged positions (e.g., leveraged staking, yield farming) 
    /// where users borrow assets to amplify their exposure, with strategy fees collected upfront. 
    ///  
    /// **Mathematical Process**: 
    /// 1. **Liquidity Validation**: Verify `strategy_amount <= available_reserves` 
    /// 2. **Total Debt Calculation**: `total_debt = strategy_amount + strategy_fee` 
    /// 3. **Scaling Conversion**: `scaled_debt = total_debt / current_borrow_index` 
    /// 4. **Position Update**: `new_scaled_debt = old_scaled_debt + scaled_debt` 
    /// 5. **Pool State Update**: `total_borrowed += scaled_debt` 
    /// 6. **Revenue Collection**: Add `strategy_fee` to protocol treasury 
    /// 7. **Asset Transfer**: Send `strategy_amount` to user for strategy execution 
    ///  
    /// **Strategy Debt Structure**: 
    /// ``` 
    /// // User receives strategy_amount but owes total_debt: 
    /// assets_received = strategy_amount 
    /// debt_created = strategy_amount + strategy_fee 
    /// protocol_fee = strategy_fee (collected immediately) 
    /// ``` 
    ///  
    /// **Interest Accrual on Total Debt**: 
    /// The entire debt (including the upfront fee) accrues interest over time: 
    /// ``` 
    /// initial_scaled_debt = (strategy_amount + strategy_fee) / borrow_index_at_creation 
    /// future_debt = initial_scaled_debt * current_borrow_index 
    /// total_repayment_needed = future_debt 
    /// ``` 
    ///  
    /// **Leveraged Position Example**: 
    /// ``` 
    /// User wants 2x leverage on 100 USDC: 
    /// 1. User supplies 100 USDC as collateral 
    /// 2. Strategy borrows 100 USDC (+ 1 USDC fee) 
    /// 3. User receives 100 USDC to buy more assets 
    /// 4. User's debt: 101 USDC (accruing interest) 
    /// 5. User's exposure: 200 USDC worth of assets 
    /// ``` 
    ///  
    /// **Fee Collection Model**: 
    /// Strategy fees are collected upfront and added to protocol revenue, 
    /// providing immediate income while the borrowed amount generates ongoing interest. 
    ///  
    /// # Arguments 
    /// - `position`: User's existing borrow position for this asset 
    /// - `strategy_amount`: Amount to borrow for strategy execution 
    /// - `strategy_fee`: Upfront fee charged for strategy creation 
    /// - `price`: Asset price for event logging 
    ///  
    /// # Returns 
    /// - Updated position with increased scaled debt (amount + fee) 
    ///  
    /// **Security Considerations**: 
    /// - Liquidity validation prevents over-borrowing 
    /// - Asset validation ensures correct token 
    /// - Upfront fee collection reduces protocol risk 
    /// - Debt includes fee to prevent undercollateralization 
    pub fn create_strategy<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg3: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        strategy_amount: Arg1,
        strategy_fee: Arg2,
        price: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createStrategy")
            .argument(&position)
            .argument(&strategy_amount)
            .argument(&strategy_fee)
            .argument(&price)
            .original_result()
    }

    /// Socializes bad debt by immediately reducing the supply index, distributing losses among all suppliers. 
    ///  
    /// **Purpose**: Prevents supplier flight during bad debt events by immediately socializing 
    /// losses rather than allowing infinite interest accrual on uncollectable debt. 
    ///  
    /// **Problem Being Solved**: 
    /// Traditional bad debt handling creates a race condition where rational suppliers 
    /// would withdraw immediately upon learning of bad debt, leaving remaining suppliers 
    /// to bear disproportionate losses. This mechanism prevents such dynamics. 
    ///  
    /// **Mathematical Process**: 
    /// 1. **Current Debt Calculation**: `bad_debt = scaled_debt * current_borrow_index` 
    /// 2. **Total Supply Value**: `total_value = total_scaled_supply * current_supply_index` 
    /// 3. **Loss Ratio Calculation**: `loss_ratio = bad_debt / total_value` 
    /// 4. **Supply Index Reduction**: `new_supply_index = old_supply_index * (1 - loss_ratio)` 
    /// 5. **Debt Removal**: Remove scaled debt from total borrowed 
    /// 6. **Position Clearing**: Set position scaled amount to zero 
    ///  
    /// **Socialization Formula**: 
    /// ``` 
    /// // Immediate loss distribution: 
    /// total_supplier_value = total_scaled_supplied * supply_index 
    /// loss_per_unit = bad_debt_amount / total_supplier_value 
    /// new_supply_index = old_supply_index * (1 - loss_per_unit) 
    ///  
    /// // Each supplier's loss: 
    /// supplier_loss = supplier_scaled_tokens * old_supply_index * loss_per_unit 
    /// supplier_new_value = supplier_scaled_tokens * new_supply_index 
    /// ``` 
    ///  
    /// **Prevention of Supplier Flight**: 
    /// By applying losses immediately and proportionally, no supplier can avoid 
    /// their share by withdrawing after bad debt is discovered. 
    ///  
    /// **Economic Rationale**: 
    /// - Spreads losses fairly among all participants 
    /// - Maintains pool stability during stress events 
    /// - Prevents bank-run scenarios 
    /// - Eliminates need for bad debt tracking/provisioning 
    ///  
    /// **Impact on Existing Positions**: 
    /// All existing supply positions instantly lose value proportional to the bad debt, 
    /// but their scaled token amounts remain unchanged. 
    ///  
    /// # Arguments 
    /// - `position`: The insolvent borrow position to clear 
    /// - `price`: Asset price for event logging 
    ///  
    /// # Returns 
    /// - Cleared position with zero scaled debt 
    ///  
    /// **Security Considerations**: 
    /// - Immediate application prevents gaming/arbitrage 
    /// - Proportional distribution ensures fairness 
    /// - Supply index has minimum floor to prevent total collapse 
    pub fn add_bad_debt<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        price: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addBadDebt")
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Seizes dust collateral from a position, transferring it directly to protocol revenue. 
    ///  
    /// **Purpose**: Enables collection of economically unviable small collateral amounts 
    /// that remain after liquidations, converting them to protocol revenue. 
    ///  
    /// **Use Case Scenario**: 
    /// After a liquidation and bad debt socialization, a user's supply position may 
    /// have a small remaining balance that is: 
    /// - Too small to be economically liquidated (gas costs > value) 
    /// - Below minimum transaction thresholds 
    /// - Creates accounting complexity if left unclaimed 
    ///  
    /// **Mathematical Process**: 
    /// 1. **Global Sync**: Update indexes to current state 
    /// 2. **Direct Transfer**: `protocol_revenue += position.scaled_amount` 
    /// 3. **Position Clearing**: `position.scaled_amount = 0` 
    /// 4. **Supply Maintenance**: Total supplied remains unchanged (dust becomes revenue) 
    ///  
    /// **Revenue Conversion**: 
    /// ``` 
    /// // Dust collateral becomes protocol revenue: 
    /// dust_value = scaled_dust * current_supply_index 
    /// protocol_revenue_scaled += scaled_dust 
    /// user_position_scaled = 0 
    /// ``` 
    ///  
    /// **Economic Justification**: 
    /// Small balances create operational overhead and user confusion. 
    /// Converting them to protocol revenue: 
    /// - Simplifies account management 
    /// - Reduces storage requirements 
    /// - Provides clean closure of positions 
    /// - Generates modest protocol income 
    ///  
    /// **Dust Threshold Considerations**: 
    /// While this function doesn't enforce a threshold, it's typically used for 
    /// amounts that are economically unviable for users to withdraw due to 
    /// transaction costs exceeding the value. 
    ///  
    /// **Impact on Pool Accounting**: 
    /// - User's scaled position: reduced to zero 
    /// - Protocol revenue: increased by dust amount 
    /// - Total supplied: unchanged (internal transfer) 
    /// - Pool liquidity: unchanged 
    ///  
    /// # Arguments 
    /// - `position`: Supply position containing dust collateral 
    /// - `price`: Asset price for event logging 
    ///  
    /// # Returns 
    /// - Cleared position with zero scaled supply 
    ///  
    /// **Security Considerations**: 
    /// - Should only be used for genuinely uneconomical amounts 
    /// - Requires careful governance to prevent abuse 
    /// - Position is completely cleared (irreversible) 
    pub fn seize_dust_collateral<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        price: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("seizeDustCollateral")
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Claims accumulated protocol revenue and transfers it to the owner. 
    ///  
    /// **Purpose**: Enables protocol owner to withdraw earned revenue from various sources 
    /// including interest spreads, flash loan fees, strategy fees, and liquidation fees. 
    ///  
    /// **Mathematical Process**: 
    /// 1. **Global Sync**: Update indexes to include latest revenue 
    /// 2. **Revenue Calculation**: `revenue_actual = revenue_scaled * current_supply_index` 
    /// 3. **Available Balance Check**: Determine withdrawable amount based on reserves 
    /// 4. **Empty Pool Handling**: If pool has no user funds, claim entire contract balance 
    /// 5. **Proportional Withdrawal**: If partial withdrawal, burn proportional scaled revenue 
    /// 6. **Transfer Execution**: Send claimed amount to controller 
    ///  
    /// **Revenue Sources**: 
    /// ``` 
    /// Protocol Revenue += { 
    ///     interest_spread: (borrow_rate - supply_rate) * borrowed_amount * time 
    ///     flash_loan_fees: loan_amount * flash_fee_rate 
    ///     strategy_fees: strategy_amount * strategy_fee_rate 
    ///     liquidation_fees: liquidated_amount * liquidation_fee_rate 
    ///     dust_collateral: seized_dust_amounts 
    /// } 
    /// ``` 
    ///  
    /// **Empty Pool Logic**: 
    /// When `user_supplied_scaled = 0` and `borrowed_scaled = 0`: 
    /// - All contract balance belongs to protocol 
    /// - Claim entire available balance 
    /// - Useful for final revenue extraction 
    ///  
    /// **Partial Withdrawal Mechanics**: 
    /// ``` 
    /// // When reserves < total_revenue: 
    /// withdrawal_ratio = available_reserves / total_revenue_value 
    /// scaled_to_burn = revenue_scaled * withdrawal_ratio 
    /// remaining_revenue_scaled = revenue_scaled - scaled_to_burn 
    /// ``` 
    ///  
    /// **Reserve Constraints**: 
    /// Revenue withdrawal is limited by available contract balance to ensure 
    /// user withdrawals remain possible. 
    ///  
    /// **Accounting Precision**: 
    /// Uses scaled amounts to maintain precision in revenue tracking, 
    /// preventing rounding errors from accumulating over time. 
    ///  
    /// **Revenue Realization**: 
    /// Revenue is stored as scaled supply tokens that appreciate with the supply index, 
    /// ensuring protocol revenue grows alongside user deposits. 
    ///  
    /// # Arguments 
    /// - `price`: Asset price for event logging 
    ///  
    /// # Returns 
    /// - Payment object representing the claimed revenue amount 
    ///  
    /// **Security Considerations**: 
    /// - Reserve validation ensures pool liquidity preservation 
    /// - Empty pool detection prevents user fund seizure 
    /// - Proportional burning maintains accurate accounting 
    /// - Only callable by owner (controller contract) 
    pub fn claim_revenue<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        price: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRevenue")
            .argument(&price)
            .original_result()
    }

    /// Retrieves the current capital utilization of the pool. 
    ///  
    /// **Purpose**: Calculates the percentage of supplied assets currently being borrowed, 
    /// which is the primary driver of interest rates in the lending protocol. 
    ///  
    /// **Mathematical Formula**: 
    /// ``` 
    /// total_borrowed_value = borrowed_scaled * current_borrow_index 
    /// total_supplied_value = supplied_scaled * current_supply_index 
    /// utilization = total_borrowed_value / total_supplied_value 
    /// ``` 
    ///  
    /// **Utilization Impact on Rates**: 
    /// - Low utilization (0-80%): Gradual rate increases 
    /// - High utilization (80%+): Steep rate increases (above kink point) 
    /// - 100% utilization: Maximum borrow rates to incentivize repayment 
    ///  
    /// **Edge Cases**: 
    /// - Zero supply: Returns 0% utilization (no funds to borrow) 
    /// - Zero borrows: Returns 0% utilization (full liquidity available) 
    ///  
    /// # Returns 
    /// - Utilization ratio as a decimal (0.0 to 1.0, where 1.0 = 100%) 
    pub fn get_capital_utilisation(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCapitalUtilisation")
            .original_result()
    }

    /// Retrieves the total actual balance of the asset held by the pool contract. 
    ///  
    /// **Purpose**: Returns the current liquidity available for withdrawals and new borrows, 
    /// representing the pool's immediate cash position. 
    ///  
    /// **Calculation**: 
    /// ``` 
    /// reserves = blockchain.get_sc_balance(asset_id) 
    /// ``` 
    /// This is the raw token balance held by the smart contract. 
    ///  
    /// **Reserve Dynamics**: 
    /// - Increases with: User deposits, loan repayments, flash loan fees 
    /// - Decreases with: User withdrawals, new loans, flash loan disbursements 
    /// - Should equal: Total supplied value - Total borrowed value + Accrued fees 
    ///  
    /// **Liquidity Constraints**: 
    /// Available reserves limit: 
    /// - Maximum withdrawal amounts 
    /// - Maximum new borrow amounts 
    /// - Flash loan capacity 
    ///  
    /// **Critical for**: 
    /// - Liquidity monitoring 
    /// - Maximum transaction sizing 
    /// - Protocol solvency verification 
    ///  
    /// # Returns 
    /// - Current asset balance of the pool contract in asset decimals 
    pub fn get_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReserves")
            .original_result()
    }

    /// Retrieves the current deposit rate for the pool. 
    ///  
    /// **Purpose**: Calculates the annual percentage yield (APY) that suppliers earn 
    /// on their deposits, based on current pool utilization and borrower interest. 
    ///  
    /// **Mathematical Formula**: 
    /// ``` 
    /// deposit_rate = borrow_rate * utilization * (1 - reserve_factor) 
    /// ``` 
    ///  
    /// **Rate Derivation Process**: 
    /// 1. **Utilization Calculation**: `borrowed_value / supplied_value` 
    /// 2. **Borrow Rate Lookup**: Rate based on utilization curve 
    /// 3. **Revenue Sharing**: Split between suppliers and protocol 
    /// 4. **Effective Rate**: `borrow_rate * utilization * supplier_share` 
    ///  
    /// **Economic Logic**: 
    /// - Higher utilization → Higher borrow rates → Higher deposit rates 
    /// - Reserve factor reduces supplier share (protocol revenue) 
    /// - Rate automatically adjusts to market conditions 
    ///  
    /// **Example Calculation**: 
    /// ``` 
    /// utilization = 80% 
    /// borrow_rate = 10% APR 
    /// reserve_factor = 20% 
    /// deposit_rate = 10% * 80% * (1 - 20%) = 6.4% APR 
    /// ``` 
    ///  
    /// # Returns 
    /// - Annual deposit rate as a decimal (e.g., 0.064 = 6.4% APR) 
    pub fn get_deposit_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepositRate")
            .original_result()
    }

    /// Retrieves the current borrow rate for the pool. 
    ///  
    /// **Purpose**: Calculates the annual percentage rate (APR) that borrowers pay 
    /// for loans, based on current pool utilization and rate curve parameters. 
    ///  
    /// **Mathematical Formula**: 
    /// ``` 
    /// if utilization <= kink_point: 
    ///     rate = base_rate + (utilization * slope1) 
    /// else: 
    ///     rate = base_rate + (kink_point * slope1) + ((utilization - kink_point) * slope2) 
    /// ``` 
    ///  
    /// **Rate Curve Properties**: 
    /// - **Base Rate**: Minimum rate even at 0% utilization 
    /// - **Slope1**: Gradual increase up to kink point (typically 80%) 
    /// - **Kink Point**: Utilization threshold for steep rate increases 
    /// - **Slope2**: Steep increase above kink to discourage over-borrowing 
    ///  
    /// **Economic Purpose**: 
    /// - Low rates at low utilization encourage borrowing 
    /// - Moderate rates at medium utilization maintain equilibrium 
    /// - High rates at high utilization protect pool liquidity 
    /// - Maximum rates near 100% utilization force repayment 
    ///  
    /// **Example Rate Curve**: 
    /// ``` 
    /// Utilization:  0%    40%    80%    95% 
    /// Borrow Rate:  2%    6%     10%    50% 
    /// ``` 
    ///  
    /// # Returns 
    /// - Annual borrow rate as a decimal (e.g., 0.10 = 10% APR) 
    pub fn get_borrow_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowRate")
            .original_result()
    }

    /// Retrieves the time delta since the last update. 
    ///  
    /// **Purpose**: Returns the elapsed time since the last global synchronization, 
    /// indicating how much interest has accrued but not yet been applied to indexes. 
    ///  
    /// **Time Measurement**: 
    /// ``` 
    /// delta_ms = current_block_timestamp * 1000 - last_timestamp 
    /// delta_seconds = delta_ms / 1000 
    /// ``` 
    ///  
    /// **Interest Accrual Relationship**: 
    /// - Larger deltas → More accumulated interest awaiting application 
    /// - Zero delta → Indexes are fully up to date 
    /// - Regular updates minimize compound interest approximation errors 
    ///  
    /// **Usage**: 
    /// - Monitor pool update frequency 
    /// - Calculate pending interest before transactions 
    /// - Estimate gas costs for index updates 
    ///  
    /// # Returns 
    /// - Time elapsed since last update in milliseconds 
    pub fn get_delta_time(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDeltaTime")
            .original_result()
    }

    /// Retrieves the protocol revenue accrued from borrow interest fees, scaled to the asset's decimals. 
    ///  
    /// **Purpose**: Returns the current value of protocol treasury holdings, 
    /// representing accumulated revenue from various protocol operations. 
    ///  
    /// **Calculation**: 
    /// ``` 
    /// revenue_actual = revenue_scaled * current_supply_index 
    /// ``` 
    ///  
    /// **Revenue Sources**: 
    /// - Interest rate spreads (reserve factor percentage) 
    /// - Flash loan fees 
    /// - Strategy creation fees 
    /// - Liquidation fees 
    /// - Seized dust collateral 
    ///  
    /// **Revenue Appreciation**: 
    /// Protocol revenue is stored as scaled supply tokens that appreciate 
    /// with the supply index, ensuring the treasury earns interest on its holdings. 
    ///  
    /// **Claimable Amount**: 
    /// The actual claimable amount may be limited by available pool reserves, 
    /// ensuring user withdrawal capacity is preserved. 
    ///  
    /// # Returns 
    /// - Current protocol revenue value in asset decimals 
    pub fn get_protocol_revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProtocolRevenue")
            .original_result()
    }

    /// Retrieves the total amount supplied to the pool. 
    ///  
    /// **Purpose**: Returns the current total value of all user deposits including accrued interest, 
    /// representing the total funds available for borrowing and protocol operations. 
    ///  
    /// **Calculation**: 
    /// ``` 
    /// supplied_actual = supplied_scaled * current_supply_index 
    /// ``` 
    ///  
    /// **Value Components**: 
    /// - Original user deposits (principal) 
    /// - Accrued interest from borrower payments 
    /// - Protocol revenue (treasury holdings) 
    ///  
    /// **Supply Growth Mechanism**: 
    /// Total supplied value increases through: 
    /// - New user deposits 
    /// - Interest payments from borrowers 
    /// - Flash loan and strategy fees 
    /// - Supply index appreciation over time 
    ///  
    /// **Relationship to Reserves**: 
    /// ``` 
    /// supplied_value = borrowed_value + available_reserves + protocol_revenue 
    /// ``` 
    ///  
    /// # Returns 
    /// - Total supplied value including interest in asset decimals 
    pub fn get_supplied_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSuppliedAmount")
            .original_result()
    }

    /// Retrieves the total amount borrowed from the pool. 
    ///  
    /// **Purpose**: Returns the current total debt owed by all borrowers including accrued interest, 
    /// representing the total outstanding obligations to the pool. 
    ///  
    /// **Calculation**: 
    /// ``` 
    /// borrowed_actual = borrowed_scaled * current_borrow_index 
    /// ``` 
    ///  
    /// **Debt Components**: 
    /// - Original borrowed principal amounts 
    /// - Compound interest accrued over time 
    /// - Strategy fees included in debt positions 
    ///  
    /// **Debt Growth Mechanism**: 
    /// Total borrowed value increases through: 
    /// - New borrowing activity 
    /// - Compound interest accrual 
    /// - Strategy creation with upfront fees 
    /// - Borrow index appreciation over time 
    ///  
    /// **Interest Generation**: 
    /// The difference between borrowed and supplied values represents 
    /// the interest being generated for suppliers and protocol revenue. 
    ///  
    /// **Utilization Calculation**: 
    /// ``` 
    /// utilization = total_borrowed / total_supplied 
    /// ``` 
    ///  
    /// # Returns 
    /// - Total borrowed value including interest in asset decimals 
    pub fn get_borrowed_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowedAmount")
            .original_result()
    }
}
