// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LiquidityPoolProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LiquidityPoolProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LiquidityPoolProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LiquidityPoolProxyMethods { wrapped_tx: tx }
    }
}

pub struct LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LiquidityPoolProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the liquidity pool for a specific asset. 
    ///  
    /// **Purpose**: Sets up the initial state of the liquidity pool, including the asset, interest rate parameters, 
    /// supply and borrow indexes, and other key variables, preparing it for lending operations. 
    ///  
    /// **Process**: 
    /// 1. Stores the pool's asset identifier. 
    /// 2. Configures interest rate parameters (`max_borrow_rate`, `base_borrow_rate`, `slope1`, `slope2`, `slope3`, `mid_utilization`, `optimal_utilization`, `reserve_factor`) 
    ///    by converting `BigUint` inputs to `ManagedDecimal` with appropriate scaling (RAY for rates, BPS for reserve factor). 
    /// 3. Initializes the borrow and supply indexes to `RAY` (representing 1.0 in the system's precision). 
    /// 4. Sets initial values for supplied, reserves, borrowed, and revenue to zero, using the asset's decimal precision. 
    /// 5. Records the current blockchain timestamp as the last update time. 
    ///  
    /// ### Parameters 
    /// - `asset`: The asset identifier (`EgldOrEsdtTokenIdentifier`) for the pool. 
    /// - `max_borrow_rate`: Maximum borrow rate (`BigUint`), scaled to RAY precision. 
    /// - `base_borrow_rate`: Base borrow rate (`BigUint`), scaled to RAY precision. 
    /// - `slope1`: Slope before optimal utilization (`BigUint`), scaled to RAY precision. 
    /// - `slope2`: Slope after optimal utilization (`BigUint`), scaled to RAY precision. 
    /// - `slope3`: Slope for high utilization (`BigUint`), scaled to RAY precision. 
    /// - `mid_utilization`: Midpoint utilization ratio (`BigUint`), scaled to RAY precision. 
    /// - `optimal_utilization`: Optimal utilization ratio (`BigUint`), scaled to RAY precision. 
    /// - `reserve_factor`: Fraction of interest reserved as protocol fee (`BigUint`), scaled to BPS precision. 
    /// - `asset_decimals`: Number of asset_decimals for the asset (`usize`). 
    ///  
    /// ### Returns 
    /// - Nothing (void function). 
    ///  
    /// **Security Considerations**: 
    /// - Ensures all critical state variables (asset, parameters, indexes, etc.) are initialized to prevent uninitialized storage vulnerabilities. 
    /// - Uses precise decimal conversions (`to_decimal_ray` and `to_decimal_bps`) to maintain calculation accuracy. 
    pub fn init<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
        Arg9: ProxyArg<usize>,
    >(
        self,
        asset: Arg0,
        max_borrow_rate: Arg1,
        base_borrow_rate: Arg2,
        slope1: Arg3,
        slope2: Arg4,
        slope3: Arg5,
        mid_utilization: Arg6,
        optimal_utilization: Arg7,
        reserve_factor: Arg8,
        asset_decimals: Arg9,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&asset)
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .argument(&asset_decimals)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Upgrades the liquidity pool parameters. 
    ///  
    /// **Purpose**: Updates the pool's interest rate parameters and reserve factor to adapt to changing market conditions 
    /// or protocol requirements, ensuring flexibility in pool management. 
    ///  
    /// **Process**: 
    /// 1. Emits an event (`market_params_event`) with the new parameters for transparency and auditability. 
    /// 2. Updates the existing pool parameters by converting `BigUint` inputs to `ManagedDecimal` with appropriate scaling. 
    ///  
    /// ### Parameters 
    /// - `max_borrow_rate`: New maximum borrow rate (`BigUint`), scaled to RAY precision. 
    /// - `base_borrow_rate`: New base borrow rate (`BigUint`), scaled to RAY precision. 
    /// - `slope1`: New slope before optimal utilization (`BigUint`), scaled to RAY precision. 
    /// - `slope2`: New slope after optimal utilization (`BigUint`), scaled to RAY precision. 
    /// - `slope3`: New slope for high utilization (`BigUint`), scaled to RAY precision. 
    /// - `mid_utilization`: New midpoint utilization ratio (`BigUint`), scaled to RAY precision. 
    /// - `optimal_utilization`: New optimal utilization ratio (`BigUint`), scaled to RAY precision. 
    /// - `reserve_factor`: New fraction of interest reserved as protocol fee (`BigUint`), scaled to BPS precision. 
    ///  
    /// ### Returns 
    /// - Nothing (void function). 
    ///  
    /// **Security Considerations**: 
    /// - Restricted to the contract owner (via the `#[upgrade]` attribute) to prevent unauthorized modifications. 
    /// - Uses precise decimal conversions (`to_decimal_ray` and `to_decimal_bps`) to ensure consistency in calculations. 
    /// - Logs changes via an event, enabling tracking and verification of updates. 
    pub fn upgrade<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        max_borrow_rate: Arg0,
        base_borrow_rate: Arg1,
        slope1: Arg2,
        slope2: Arg3,
        slope3: Arg4,
        mid_utilization: Arg5,
        optimal_utilization: Arg6,
        reserve_factor: Arg7,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquidityPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the pool asset identifier. 
    ///  
    /// # Returns 
    /// - `EgldOrEsdtTokenIdentifier`: The asset managed by this pool. 
    pub fn pool_asset(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolAsset")
            .original_result()
    }

    /// Retrieves the total amount supplied to the pool. 
    ///  
    /// # Returns 
    /// - `BigUint`: The total supplied tokens. 
    pub fn supplied(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSuppliedAmount")
            .original_result()
    }

    /// Retrieves the protocol revenue accrued from borrow interest fees. 
    ///  
    /// # Returns 
    /// - `BigUint`: The accumulated protocol revenue. 
    pub fn revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProtocolRevenue")
            .original_result()
    }

    /// Retrieves the total borrowed amount from the pool. 
    ///  
    /// # Returns 
    /// - `BigUint`: The total tokens borrowed. 
    pub fn borrowed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrow")
            .original_result()
    }

    /// Retrieves the total bad debt from the pool. 
    ///  
    /// # Returns 
    /// - `BigUint`: The total bad debt pending to be collected. 
    pub fn bad_debt(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBadDebt")
            .original_result()
    }

    /// Returns the market parameters. 
    ///  
    /// These include interest rate parameters and asset asset_decimals. 
    ///  
    /// # Returns 
    /// - `MarketParams<Self::Api>`: The market configuration. 
    pub fn params(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::MarketParams<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getParams")
            .original_result()
    }

    /// Retrieves the current borrow index. 
    ///  
    /// The borrow index is used to calculate accrued interest on borrow positions. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current borrow index. 
    pub fn borrow_index(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowIndex")
            .original_result()
    }

    /// Retrieves the current supply index. 
    ///  
    /// The supply index is used to compute the yield for suppliers. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current supply index. 
    pub fn supply_index(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSupplyIndex")
            .original_result()
    }

    /// Retrieves the last update timestamp for the interest indexes. 
    ///  
    /// # Returns 
    /// - `u64`: The timestamp when indexes were last updated. 
    pub fn last_timestamp(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastTimestamp")
            .original_result()
    }

    /// Updates the market's borrow and supply indexes based on elapsed time since the last update. 
    ///  
    /// **Purpose**: Ensures the pool's interest calculations reflect the latest state by computing an interest factor based on time elapsed and applying it to the borrow and supply indexes. 
    ///  
    /// **Process**: 
    /// 1. Creates a `Cache` to snapshot the current pool state. 
    /// 2. Calls `global_sync` to update the borrow and supply indexes. 
    /// 3. Emits a market state event to log the updated state. 
    ///  
    /// # Arguments 
    /// - `price`: The current price of the pool asset (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// **Security Considerations**: Restricted to the owner (via controller contract) to ensure controlled updates. 
    pub fn update_indexes<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        price: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::MarketIndex<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateIndexes")
            .argument(&price)
            .original_result()
    }

    /// Supplies assets to the lending pool, increasing reserves and the supplier's position. 
    ///  
    /// **Purpose**: Allows users to deposit assets into the pool to earn interest, increasing available liquidity. 
    ///  
    /// **Process**: 
    /// 1. Retrieves and validates the payment amount using `get_payment_amount`. 
    /// 2. Updates global indexes and the supplier's position with accrued interest. 
    /// 3. Adds the supplied amount to the position, reserves, and total supplied. 
    /// 4. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `position`: The supplier's current position (`AccountPosition<Self::Api>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `AccountPosition<Self::Api>`: The updated position with the new supply amount. 
    ///  
    /// **Security Considerations**: Validates the asset type via `get_payment_amount` to ensure only the pool's asset is supplied. 
    /// Can only be called by the owner (via controller contract). 
    pub fn supply<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        price: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .raw_call("supply")
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Borrows assets from the pool against a user's collateral. 
    ///  
    /// **Purpose**: Enables users to borrow assets, deducting from reserves and increasing their debt. 
    ///  
    /// **Process**: 
    /// 1. Updates global indexes and the borrower's position with accrued interest. 
    /// 2. Verifies sufficient reserves are available. 
    /// 3. Increases the borrower's debt and total borrowed, then deducts from reserves. 
    /// 4. Transfers the borrowed amount to the caller. 
    /// 5. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `initial_caller`: The borrower's address (`ManagedAddress`). 
    /// - `amount`: The amount to borrow (`ManagedDecimal<Self::Api, NumDecimals>`). 
    /// - `position`: The borrower's current position (`AccountPosition<Self::Api>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `AccountPosition<Self::Api>`: The updated borrow position. 
    ///  
    /// **Security Considerations**: Uses `require!` to ensure sufficient liquidity, preventing over-borrowing. 
    /// Can only be called by the owner (via controller contract). 
    pub fn borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg3: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        amount: Arg1,
        position: Arg2,
        price: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrow")
            .argument(&initial_caller)
            .argument(&amount)
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Withdraws assets from the pool, supporting both normal withdrawals and liquidations. 
    ///  
    /// **Purpose**: Allows suppliers to retrieve their assets or handles liquidation events, adjusting for interest and fees. 
    ///  
    /// **Process**: 
    /// 1. Updates global indexes. 
    /// 2. Caps the withdrawal amount to the position's total (principal + interest). 
    /// 3. Calculates principal, interest, and total withdrawal amount, applying liquidation fees if applicable. 
    /// 4. Verifies sufficient reserves and supplied amounts. 
    /// 5. Updates the pool state and position, then transfers the withdrawal amount. 
    /// 6. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `initial_caller`: The address withdrawing funds (`ManagedAddress`). 
    /// - `amount`: Requested withdrawal amount (`ManagedDecimal<Self::Api, NumDecimals>`). 
    /// - `position`: The supplier's position (`AccountPosition<Self::Api>`). 
    /// - `is_liquidation`: Indicates if this is a liquidation event (`bool`). 
    /// - `protocol_fee_opt`: Optional liquidation fee (`Option<ManagedDecimal<Self::Api, NumDecimals>>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `AccountPosition<Self::Api>`: The updated position after withdrawal. 
    ///  
    /// **Security Considerations**: Caps withdrawal amounts and uses `require!` to prevent over-withdrawal from reserves or supplied totals. 
    /// Can only be called by the owner (via controller contract). 
    pub fn withdraw<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg3: ProxyArg<bool>,
        Arg4: ProxyArg<Option<ManagedDecimal<Env::Api, usize>>>,
        Arg5: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        amount: Arg1,
        position: Arg2,
        is_liquidation: Arg3,
        protocol_fee_opt: Arg4,
        price: Arg5,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdraw")
            .argument(&initial_caller)
            .argument(&amount)
            .argument(&position)
            .argument(&is_liquidation)
            .argument(&protocol_fee_opt)
            .argument(&price)
            .original_result()
    }

    /// Processes a repayment for a borrow position, handling full or partial repayments. 
    ///  
    /// **Purpose**: Reduces a borrower's debt by allocating repayment to principal and interest, refunding any overpayment. 
    ///  
    /// **Process**: 
    /// 1. Retrieves and validates the repayment amount. 
    /// 2. Updates global indexes and the position with accrued interest. 
    /// 3. Splits the repayment into principal, interest, and overpayment using `split_repay`. 
    /// 4. Updates the position and pool state, refunding any overpayment. 
    /// 5. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `initial_caller`: The address repaying the debt (`ManagedAddress`). 
    /// - `position`: The borrower's current position (`AccountPosition<Self::Api>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `AccountPosition<Self::Api>`: The updated position after repayment. 
    ///  
    /// **Security Considerations**: Ensures asset validity via `get_payment_amount` and handles overpayments to prevent fund loss. 
    /// Can only be called by the owner (via controller contract). 
    pub fn repay<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg2: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        initial_caller: Arg0,
        position: Arg1,
        price: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .raw_call("repay")
            .argument(&initial_caller)
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Provides a flash loan from the pool, enabling temporary borrowing without collateral. 
    ///  
    /// **Purpose**: Facilitates flash loans for strategies like arbitrage, requiring repayment with fees in the same transaction. 
    ///  
    /// **Process**: 
    /// 1. Validates the borrowed token and reserve availability. 
    /// 2. Deducts the loan amount from reserves. 
    /// 3. Computes the required repayment with fees. 
    /// 4. Drops the cache to prevent reentrancy, executes an external call, and validates repayment. 
    /// 5. Updates reserves and protocol revenue with the repayment and fee. 
    /// 6. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `borrowed_token`: The token to borrow (`EgldOrEsdtTokenIdentifier`). 
    /// - `amount`: The amount to borrow (`ManagedDecimal<Self::Api, NumDecimals>`). 
    /// - `contract_address`: The target contract address (`ManagedAddress`). 
    /// - `endpoint`: The endpoint to call (`ManagedBuffer<Self::Api>`). 
    /// - `arguments`: Arguments for the endpoint (`ManagedArgBuffer<Self::Api>`). 
    /// - `fees`: The flash loan fee rate (`ManagedDecimal<Self::Api, NumDecimals>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// **Security Considerations**: Drops the cache before external calls to prevent reentrancy and uses `require!` to enforce asset and reserve checks. 
    /// Can only be called by the owner (via controller contract). 
    pub fn flash_loan<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<ManagedArgBuffer<Env::Api>>,
        Arg5: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg6: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        borrowed_token: Arg0,
        amount: Arg1,
        contract_address: Arg2,
        endpoint: Arg3,
        arguments: Arg4,
        fees: Arg5,
        price: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("flashLoan")
            .argument(&borrowed_token)
            .argument(&amount)
            .argument(&contract_address)
            .argument(&endpoint)
            .argument(&arguments)
            .argument(&fees)
            .argument(&price)
            .original_result()
    }

    /// Simulates a flash loan strategy by borrowing assets without immediate repayment. 
    ///  
    /// **Purpose**: Enables internal strategies requiring temporary asset access, adding fees to protocol revenue. 
    ///  
    /// **Process**: 
    /// 1. Validates the token and reserve availability. 
    /// 2. Deducts from reserves, increases borrowed amount, and adds fees to revenue. 
    /// 3. Transfers the borrowed amount to the caller. 
    /// 4. Emits a market state event and returns the borrow index and timestamp. 
    ///  
    /// # Arguments 
    /// - `token`: The token to borrow (`EgldOrEsdtTokenIdentifier`). 
    /// - `strategy_amount`: The amount to borrow (`ManagedDecimal<Self::Api, NumDecimals>`). 
    /// - `strategy_fee`: The fee for the strategy (`ManagedDecimal<Self::Api, NumDecimals>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `(ManagedDecimal<Self::Api, NumDecimals>, u64)`: The current borrow index and timestamp for later position updates. 
    ///  
    /// **Security Considerations**: Ensures asset validity and sufficient reserves with `require!` checks. 
    /// Can only be called by the owner (via controller contract) 
    pub fn create_strategy<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg2: ProxyArg<ManagedDecimal<Env::Api, usize>>,
        Arg3: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        strategy_amount: Arg1,
        strategy_fee: Arg2,
        price: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createStrategy")
            .argument(&position)
            .argument(&strategy_amount)
            .argument(&strategy_fee)
            .argument(&price)
            .original_result()
    }

    /// Adds external revenue to the pool, such as from vault liquidations or other sources. 
    /// It will first pay the bad debt and then add the remaining amount to revenue and reserves. 
    ///  
    /// **Purpose**: Increases protocol revenue and reserves with funds from external sources. 
    ///  
    /// **Process**: 
    /// 1. Retrieves and validates the payment amount. 
    /// 2. Adds the amount to both revenue and reserves. 
    /// 3. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// **Security Considerations**: Validates the asset via `get_payment_amount` to ensure compatibility with the pool. 
    /// Can only be called by the owner (via controller contract). 
    pub fn add_protocol_revenue<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        price: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addProtocolRevenue")
            .argument(&price)
            .original_result()
    }

    /// Adds bad debt to the pool, such as from liquidations. 
    ///  
    /// **Purpose**: Increases protocol bad debt. 
    ///  
    /// **Reason**: After liquidations, when bad debt is left over, the position will infinitely accrue interest that will never be repaid. 
    /// This function allows the protocol to collect this bad debt and add it the bad debt tracker which will paid over time from the protocol revenue and suppliers interest. 
    ///  
    /// **Process**: 
    /// 1. Updates global indexes. 
    /// 2. Adds the amount to bad debt. 
    /// 3. Subtracts the amount from borrowed. 
    /// 4. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `position`: The position to add bad debt to (`AccountPosition<Self::Api>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `AccountPosition<Self::Api>`: The updated position after adding bad debt. 
    pub fn add_bad_debt<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        price: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addBadDebt")
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Seizes dust collateral from the pool, adding it to protocol revenue. 
    ///  
    /// **Purpose**: Allows the protocol to collect dust collateral from the pool, increasing revenue. 
    ///  
    /// **Reason**: After liquidations, when bad debt is left over, the supplied position might still have a dust balance that is not liquidatable. 
    /// This function allows the protocol to collect this dust and add it to revenue, while clearing the position and the infinite interest that would be accrued on it. 
    ///  
    /// **Process**: 
    /// 1. Updates global indexes. 
    /// 2. Adds the dust collateral to protocol revenue. 
    /// 3. Subtracts the dust collateral from supplied. 
    /// 4. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `position`: The position to seize dust collateral from (`AccountPosition<Self::Api>`). 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    pub fn seize_dust_collateral<
        Arg0: ProxyArg<common_structs::AccountPosition<Env::Api>>,
        Arg1: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        position: Arg0,
        price: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountPosition<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("seizeDustCollateral")
            .argument(&position)
            .argument(&price)
            .original_result()
    }

    /// Claims accumulated protocol revenue and transfers it to the owner. 
    ///  
    /// **Purpose**: Allows the protocol owner to withdraw earned revenue, ensuring accurate state updates. 
    ///  
    /// **Process**: 
    /// 1. Updates global indexes. 
    /// 2. Calculates available revenue, using contract balance if the pool is empty (borrowed and supplied are zero). 
    /// 3. Updates reserves and revenue, then transfers the amount to the owner. 
    /// 4. Emits a market state event. 
    ///  
    /// # Arguments 
    /// - `price`: The asset price for market update (`ManagedDecimal<Self::Api, NumDecimals>`). 
    ///  
    /// # Returns 
    /// - `EgldOrEsdtTokenPayment<Self::Api>`: The payment object representing the claimed revenue. 
    ///  
    /// **Security Considerations**: Handles edge cases (empty pool) by fallback to contract balance, ensuring all revenue is claimable. 
    pub fn claim_revenue<
        Arg0: ProxyArg<ManagedDecimal<Env::Api, usize>>,
    >(
        self,
        price: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRevenue")
            .argument(&price)
            .original_result()
    }

    /// Retrieves the current capital utilization of the pool. 
    ///  
    /// Capital utilization is defined as the ratio of borrowed tokens to the total supplied tokens. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current utilization ratio. 
    pub fn get_capital_utilisation(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCapitalUtilisation")
            .original_result()
    }

    pub fn get_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReserves")
            .original_result()
    }

    /// Retrieves the current deposit rate for the pool. 
    ///  
    /// The deposit rate is derived from capital utilization, the borrow rate, and the reserve factor. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current deposit rate. 
    pub fn get_deposit_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepositRate")
            .original_result()
    }

    /// Retrieves the current borrow rate for the pool. 
    ///  
    /// # Returns 
    /// - `ManagedDecimal<Self::Api, NumDecimals>`: The current borrow rate. 
    pub fn get_borrow_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowRate")
            .original_result()
    }

    /// Retrieves the time delta since the last update. 
    ///  
    /// # Returns 
    /// - `u64`: The time delta in seconds. 
    pub fn get_delta_time(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDeltaTime")
            .original_result()
    }

    /// Retrieves the protocol revenue accrued from borrow interest fees. 
    ///  
    /// # Returns 
    /// - `BigUint`: The accumulated protocol revenue. 
    pub fn get_protocol_revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProtocolRevenue")
            .original_result()
    }
}
