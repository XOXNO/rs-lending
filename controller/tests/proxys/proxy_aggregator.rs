// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct PriceAggregatorProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for PriceAggregatorProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = PriceAggregatorProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        PriceAggregatorProxyMethods { wrapped_tx: tx }
    }
}

pub struct PriceAggregatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> PriceAggregatorProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes price aggregator with oracle addresses and submission threshold. 
    /// Sets initial submission count and pauses contract for configuration. 
    /// Validates submission count is within acceptable bounds. 
    pub fn init<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        submission_count: Arg0,
        oracles: Arg1,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&submission_count)
            .argument(&oracles)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> PriceAggregatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Handles contract upgrade by pausing operations. 
    /// Ensures safe state during code updates. 
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> PriceAggregatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Submits a single price feed from oracle for token pair. 
    /// Validates oracle status and timestamp before processing submission. 
    /// Triggers new round creation when submission threshold is met. 
    pub fn submit<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        from: Arg0,
        to: Arg1,
        submission_timestamp: Arg2,
        price: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("submit")
            .argument(&from)
            .argument(&to)
            .argument(&submission_timestamp)
            .argument(&price)
            .original_result()
    }

    /// Submits multiple price feeds in a single transaction for gas efficiency. 
    /// Each submission is validated independently before processing. 
    /// Enables oracles to update multiple token pairs atomically. 
    pub fn submit_batch<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, MultiValue4<ManagedBuffer<Env::Api>, ManagedBuffer<Env::Api>, u64, BigUint<Env::Api>>>>,
    >(
        self,
        submissions: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("submitBatch")
            .argument(&submissions)
            .original_result()
    }

    pub fn pause_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pause")
            .original_result()
    }

    pub fn unpause_endpoint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpause")
            .original_result()
    }

    pub fn paused_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isPaused")
            .original_result()
    }

    pub fn submission_count(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("submission_count")
            .original_result()
    }

    /// Returns latest aggregated prices for multiple token pairs. 
    /// Skips pairs without available price data. 
    /// Enables batch price queries for efficiency. 
    pub fn latest_round_data<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, TokenPair<Env::Api>>>,
    >(
        self,
        pairs: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, PriceFeed<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("latestRoundData")
            .argument(&pairs)
            .original_result()
    }

    /// Returns latest aggregated price for a single token pair. 
    /// Fails if no price data exists for the requested pair. 
    /// Primary interface for price consumers. 
    pub fn latest_price_feed<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        from: Arg0,
        to: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, PriceFeed<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("latestPriceFeed")
            .argument(&from)
            .argument(&to)
            .original_result()
    }

    /// Returns all registered oracle addresses. 
    /// Used for transparency and monitoring oracle participation. 
    pub fn get_oracles(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOracles")
            .original_result()
    }

    /// Adds new oracle addresses to the whitelist. 
    /// Initializes submission statistics for each new oracle. 
    /// Skips oracles that are already registered. 
    pub fn add_oracles<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        oracles: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addOracles")
            .argument(&oracles)
            .original_result()
    }

    /// Removes oracle addresses and updates submission count atomically. 
    /// Prevents invalid state where submission count exceeds oracle count. 
    pub fn remove_oracles<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        submission_count: Arg0,
        oracles: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeOracles")
            .argument(&submission_count)
            .argument(&oracles)
            .original_result()
    }

    /// Updates required submission count for consensus. 
    /// Validates count is within min/max bounds and doesn't exceed oracle count. 
    /// Controls how many oracle submissions trigger price aggregation. 
    pub fn set_submission_count<
        Arg0: ProxyArg<usize>,
    >(
        self,
        submission_count: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSubmissionCount")
            .argument(&submission_count)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode)]
pub struct NewRoundEvent<Api>
where
    Api: ManagedTypeApi,
{
    pub price: BigUint<Api>,
    pub timestamp: u64,
    pub block: u64,
    pub epoch: u64,
}

#[type_abi]
#[derive(TopEncode)]
pub struct DiscardSubmissionEvent {
    pub submission_timestamp: u64,
    pub first_submission_timestamp: u64,
    pub has_caller_already_submitted: bool,
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode, Clone)]
pub struct TokenPair<Api>
where
    Api: ManagedTypeApi,
{
    pub from: ManagedBuffer<Api>,
    pub to: ManagedBuffer<Api>,
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode, Clone)]
pub struct PriceFeed<Api>
where
    Api: ManagedTypeApi,
{
    pub round_id: u32,
    pub from: ManagedBuffer<Api>,
    pub to: ManagedBuffer<Api>,
    pub timestamp: u64,
    pub price: BigUint<Api>,
}
