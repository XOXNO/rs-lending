// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LendingPoolProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LendingPoolProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LendingPoolProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LendingPoolProxyMethods { wrapped_tx: tx }
    }
}

pub struct LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LendingPoolProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the lending pool contract with required addresses. 
    ///  
    /// # Arguments 
    /// - `lp_template_address`: Address of the liquidity pool template. 
    /// - `price_aggregator_address`: Address of the price aggregator. 
    /// - `safe_price_view_address`: Address for safe price views. 
    /// - `accumulator_address`: Address for revenue accumulation. 
    /// - `wegld_address`: Address for wrapped EGLD. 
    /// - `ash_swap_address`: Address for AshSwap integration. 
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
        Arg5: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        lp_template_address: Arg0,
        price_aggregator_address: Arg1,
        safe_price_view_address: Arg2,
        accumulator_address: Arg3,
        wegld_address: Arg4,
        ash_swap_address: Arg5,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&lp_template_address)
            .argument(&price_aggregator_address)
            .argument(&safe_price_view_address)
            .argument(&accumulator_address)
            .argument(&wegld_address)
            .argument(&ash_swap_address)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Supplies collateral to the lending pool. 
    ///  
    /// # Arguments 
    /// - `is_vault`: Indicates if the supply is for a vault position. 
    /// - `e_mode_category`: Optional e-mode category for specialized parameters. 
    ///  
    /// # Payment 
    /// - Accepts minimum 1 payment: optional account NFT and bulk collateral tokens. 
    pub fn supply<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<OptionalValue<u8>>,
    >(
        self,
        is_vault: Arg0,
        e_mode_category: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("supply")
            .argument(&is_vault)
            .argument(&e_mode_category)
            .original_result()
    }

    /// Withdraws collateral from the lending pool. 
    ///  
    /// # Arguments 
    /// - `collaterals`: List of tokens and amounts to withdraw. 
    ///  
    /// # Payment 
    /// - Requires account NFT payment. 
    pub fn withdraw<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>>,
    >(
        self,
        collaterals: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("withdraw")
            .argument(&collaterals)
            .original_result()
    }

    /// Borrows assets from the lending pool. 
    ///  
    /// # Arguments 
    /// - `borrowed_tokens`: List of tokens and amounts to borrow. 
    ///  
    /// # Payment 
    /// - Requires account NFT payment. 
    pub fn borrow<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>>,
    >(
        self,
        borrowed_tokens: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("borrow")
            .argument(&borrowed_tokens)
            .original_result()
    }

    /// Repays borrowed assets for an account. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    pub fn repay<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("repay")
            .argument(&account_nonce)
            .original_result()
    }

    /// Liquidates an unhealthy position. 
    ///  
    /// # Arguments 
    /// - `liquidatee_account_nonce`: NFT nonce of the account to liquidate. 
    pub fn liquidate<
        Arg0: ProxyArg<u64>,
    >(
        self,
        liquidatee_account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("liquidate")
            .argument(&liquidatee_account_nonce)
            .original_result()
    }

    /// Executes a flash loan. 
    ///  
    /// # Arguments 
    /// - `borrowed_asset_id`: Token identifier to borrow. 
    /// - `amount`: Amount to borrow. 
    /// - `contract_address`: Address of the contract to receive the loan. 
    /// - `endpoint`: Endpoint to call on the receiving contract. 
    /// - `arguments`: Arguments for the endpoint call. 
    pub fn flash_loan<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<ManagedArgBuffer<Env::Api>>,
    >(
        self,
        borrowed_asset_id: Arg0,
        amount: Arg1,
        contract_address: Arg2,
        endpoint: Arg3,
        arguments: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("flashLoan")
            .argument(&borrowed_asset_id)
            .argument(&amount)
            .argument(&contract_address)
            .argument(&endpoint)
            .argument(&arguments)
            .original_result()
    }

    /// Updates account positions with the latest interest data. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account to sync. 
    ///  
    /// # Returns 
    /// - `MultiValue2<ManagedVec<AccountPosition>, ManagedVec<AccountPosition>>`: Updated deposit and borrow positions. 
    pub fn update_account_positions<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<ManagedVec<Env::Api, common_structs::AccountPosition<Env::Api>>, ManagedVec<Env::Api, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountPositions")
            .argument(&account_nonce)
            .original_result()
    }

    /// Disables vault mode for an account, moving funds to the market pool. 
    pub fn toggle_vault<
        Arg0: ProxyArg<bool>,
    >(
        self,
        status: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("toggleVault")
            .argument(&status)
            .original_result()
    }

    /// Updates LTV or liquidation threshold for account positions of a specific asset. 
    ///  
    /// # Arguments 
    /// - `asset_id`: Token identifier to update. 
    /// - `is_ltv`: True to update LTV, false for liquidation threshold. 
    /// - `account_nonces`: List of account nonces to update. 
    pub fn update_account_threshold<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<MultiValueEncoded<Env::Api, u64>>,
    >(
        self,
        asset_id: Arg0,
        has_risks: Arg1,
        account_nonces: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountThreshold")
            .argument(&asset_id)
            .argument(&has_risks)
            .argument(&account_nonces)
            .original_result()
    }

    /// Updates interest rate indexes for specified assets. 
    ///  
    /// # Arguments 
    /// - `assets`: List of token identifiers to update. 
    pub fn update_indexes<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateIndexes")
            .argument(&assets)
            .original_result()
    }

    /// Creates a new liquidity pool for an asset with specified parameters. 
    /// Initializes the pool and configures lending/borrowing settings. 
    ///  
    /// # Arguments 
    /// - `base_asset`: Token identifier (EGLD or ESDT) of the asset. 
    /// - `max_borrow_rate`: Maximum borrow rate. 
    /// - `base_borrow_rate`: Base borrow rate. 
    /// - `slope1`, `slope2`, `slope3`: Interest rate slopes for utilization levels. 
    /// - `mid_utilization`, `optimal_utilization`: Utilization thresholds for rate calculations. 
    /// - `reserve_factor`: Fraction of interest reserved for the protocol. 
    /// - `ltv`: Loan-to-value ratio in BPS. 
    /// - `liquidation_threshold`: Liquidation threshold in BPS. 
    /// - `liquidation_base_bonus`: Base liquidation bonus in BPS. 
    /// - `liquidation_max_fee`: Maximum liquidation fee in BPS. 
    /// - `can_be_collateral`: Flag for collateral usability. 
    /// - `can_be_borrowed`: Flag for borrowability. 
    /// - `is_isolated`: Flag for isolated asset status. 
    /// - `debt_ceiling_usd`: Debt ceiling in USD for isolated assets. 
    /// - `flash_loan_fee`: Flash loan fee in BPS. 
    /// - `is_siloed`: Flag for siloed borrowing. 
    /// - `flashloan_enabled`: Flag for flash loan support. 
    /// - `can_borrow_in_isolation`: Flag for borrowing in isolation mode. 
    /// - `asset_decimals`: Number of decimals for the asset. 
    /// - `borrow_cap`: Optional borrow cap (`None` if unspecified). 
    /// - `supply_cap`: Optional supply cap (`None` if unspecified). 
    ///  
    /// # Returns 
    /// - `ManagedAddress`: Address of the newly created liquidity pool. 
    ///  
    /// # Errors 
    /// - `ERROR_ASSET_ALREADY_SUPPORTED`: If the asset already has a pool. 
    /// - `ERROR_INVALID_TICKER`: If the asset identifier is invalid. 
    /// - `ERROR_INVALID_LIQUIDATION_THRESHOLD`: If threshold is invalid. 
    pub fn create_liquidity_pool<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
        Arg9: ProxyArg<BigUint<Env::Api>>,
        Arg10: ProxyArg<BigUint<Env::Api>>,
        Arg11: ProxyArg<BigUint<Env::Api>>,
        Arg12: ProxyArg<BigUint<Env::Api>>,
        Arg13: ProxyArg<bool>,
        Arg14: ProxyArg<bool>,
        Arg15: ProxyArg<bool>,
        Arg16: ProxyArg<BigUint<Env::Api>>,
        Arg17: ProxyArg<BigUint<Env::Api>>,
        Arg18: ProxyArg<bool>,
        Arg19: ProxyArg<bool>,
        Arg20: ProxyArg<bool>,
        Arg21: ProxyArg<usize>,
        Arg22: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
        Arg23: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        base_asset: Arg0,
        max_borrow_rate: Arg1,
        base_borrow_rate: Arg2,
        slope1: Arg3,
        slope2: Arg4,
        slope3: Arg5,
        mid_utilization: Arg6,
        optimal_utilization: Arg7,
        reserve_factor: Arg8,
        ltv: Arg9,
        liquidation_threshold: Arg10,
        liquidation_base_bonus: Arg11,
        liquidation_max_fee: Arg12,
        can_be_collateral: Arg13,
        can_be_borrowed: Arg14,
        is_isolated: Arg15,
        debt_ceiling_usd: Arg16,
        flash_loan_fee: Arg17,
        is_siloed: Arg18,
        flashloan_enabled: Arg19,
        can_borrow_in_isolation: Arg20,
        asset_decimals: Arg21,
        borrow_cap: Arg22,
        supply_cap: Arg23,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createLiquidityPool")
            .argument(&base_asset)
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_base_bonus)
            .argument(&liquidation_max_fee)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .argument(&is_isolated)
            .argument(&debt_ceiling_usd)
            .argument(&flash_loan_fee)
            .argument(&is_siloed)
            .argument(&flashloan_enabled)
            .argument(&can_borrow_in_isolation)
            .argument(&asset_decimals)
            .argument(&borrow_cap)
            .argument(&supply_cap)
            .original_result()
    }

    /// Upgrades an existing liquidity pool with new parameters. 
    /// Adjusts interest rate model and reserve settings. 
    ///  
    /// # Arguments 
    /// - `base_asset`: Token identifier (EGLD or ESDT) of the asset. 
    /// - `max_borrow_rate`: New maximum borrow rate. 
    /// - `base_borrow_rate`: New base borrow rate. 
    /// - `slope1`, `slope2`, `slope3`: New interest rate slopes. 
    /// - `mid_utilization`, `optimal_utilization`: New utilization thresholds. 
    /// - `reserve_factor`: New reserve factor. 
    ///  
    /// # Errors 
    /// - `ERROR_NO_POOL_FOUND`: If no pool exists for the asset. 
    pub fn upgrade_liquidity_pool<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        base_asset: Arg0,
        max_borrow_rate: Arg1,
        base_borrow_rate: Arg2,
        slope1: Arg3,
        slope2: Arg4,
        slope3: Arg5,
        mid_utilization: Arg6,
        optimal_utilization: Arg7,
        reserve_factor: Arg8,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("upgradeLiquidityPool")
            .argument(&base_asset)
            .argument(&max_borrow_rate)
            .argument(&base_borrow_rate)
            .argument(&slope1)
            .argument(&slope2)
            .argument(&slope3)
            .argument(&mid_utilization)
            .argument(&optimal_utilization)
            .argument(&reserve_factor)
            .original_result()
    }

    /// Claims revenue from multiple liquidity pools and deposits it into the accumulator. 
    /// Collects protocol revenue from interest and fees. 
    ///  
    /// # Arguments 
    /// - `assets`: List of token identifiers (EGLD or ESDT) to claim revenue from. 
    ///  
    /// # Errors 
    /// - `ERROR_NO_ACCUMULATOR_FOUND`: If no accumulator address is set. 
    pub fn claim_revenue<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRevenue")
            .argument(&assets)
            .original_result()
    }

    /// Registers a new NFT token for tracking account positions. 
    /// Issues an ESDT token with non-fungible properties. 
    ///  
    /// # Arguments 
    /// - `token_name`: Name of the NFT token. 
    /// - `ticker`: Ticker symbol for the NFT token. 
    ///  
    /// # Notes 
    /// - Requires EGLD payment for issuance. 
    pub fn register_account_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        token_name: Arg0,
        ticker: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("registerAccountToken")
            .argument(&token_name)
            .argument(&ticker)
            .original_result()
    }

    /// Configures the oracle for a token’s price feed. 
    /// Sets up pricing method, source, and tolerances. 
    ///  
    /// # Arguments 
    /// - `market_token`: Token identifier (EGLD or ESDT). 
    /// - `decimals`: Decimal precision for the price. 
    /// - `contract_address`: Address of the oracle contract. 
    /// - `pricing_method`: Method for price determination (e.g., Safe, Aggregator). 
    /// - `token_type`: Oracle type (e.g., Normal, Derived). 
    /// - `source`: Exchange source (e.g., XExchange). 
    /// - `first_tolerance`, `last_tolerance`: Tolerance values for price fluctuations. 
    ///  
    /// # Errors 
    /// - `ERROR_ORACLE_TOKEN_NOT_FOUND`: If oracle already exists for the token. 
    pub fn set_token_oracle<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<common_structs::PricingMethod>,
        Arg4: ProxyArg<common_structs::OracleType>,
        Arg5: ProxyArg<common_structs::ExchangeSource>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        market_token: Arg0,
        decimals: Arg1,
        contract_address: Arg2,
        pricing_method: Arg3,
        token_type: Arg4,
        source: Arg5,
        first_tolerance: Arg6,
        last_tolerance: Arg7,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTokenOracle")
            .argument(&market_token)
            .argument(&decimals)
            .argument(&contract_address)
            .argument(&pricing_method)
            .argument(&token_type)
            .argument(&source)
            .argument(&first_tolerance)
            .argument(&last_tolerance)
            .original_result()
    }

    /// Updates the tolerance settings for a token’s oracle. 
    /// Adjusts acceptable price deviation ranges. 
    ///  
    /// # Arguments 
    /// - `market_token`: Token identifier (EGLD or ESDT). 
    /// - `first_tolerance`, `last_tolerance`: New tolerance values. 
    ///  
    /// # Errors 
    /// - `ERROR_ORACLE_TOKEN_NOT_FOUND`: If no oracle exists for the token. 
    pub fn edit_token_oracle_tolerance<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        market_token: Arg0,
        first_tolerance: Arg1,
        last_tolerance: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editTokenOracleTolerance")
            .argument(&market_token)
            .argument(&first_tolerance)
            .argument(&last_tolerance)
            .original_result()
    }

    /// Sets the price aggregator contract address. 
    /// Configures the source for aggregated price data. 
    ///  
    /// # Arguments 
    /// - `aggregator`: Address of the price aggregator contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_AGGREGATOR`: If address is zero or not a smart contract. 
    pub fn set_aggregator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        aggregator: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAggregator")
            .argument(&aggregator)
            .original_result()
    }

    /// Sets the accumulator contract address. 
    /// Configures where protocol revenue is collected. 
    ///  
    /// # Arguments 
    /// - `accumulator`: Address of the accumulator contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_AGGREGATOR`: If address is zero or not a smart contract. 
    pub fn set_accumulator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        accumulator: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAccumulator")
            .argument(&accumulator)
            .original_result()
    }

    /// Sets the safe price view contract address. 
    /// Configures the source for safe price data in liquidation checks. 
    ///  
    /// # Arguments 
    /// - `safe_view_address`: Address of the safe price view contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_AGGREGATOR`: If address is zero or not a smart contract. 
    pub fn set_safe_price_view<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        safe_view_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSafePriceView")
            .argument(&safe_view_address)
            .original_result()
    }

    /// Sets the template address for liquidity pools. 
    /// Used for deploying new pools with a standard template. 
    ///  
    /// # Arguments 
    /// - `address`: Address of the liquidity pool template contract. 
    ///  
    /// # Errors 
    /// - `ERROR_INVALID_LIQUIDITY_POOL_TEMPLATE`: If address is zero or not a smart contract. 
    pub fn set_liquidity_pool_template<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidityPoolTemplate")
            .argument(&address)
            .original_result()
    }

    /// Adds a new e-mode category with risk parameters. 
    /// Creates an efficiency mode for optimized asset usage. 
    ///  
    /// # Arguments 
    /// - `ltv`: Loan-to-value ratio in BPS. 
    /// - `liquidation_threshold`: Liquidation threshold in BPS. 
    /// - `liquidation_bonus`: Liquidation bonus in BPS. 
    ///  
    /// # Notes 
    /// - Assigns a new category ID automatically. 
    pub fn add_e_mode_category<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ltv: Arg0,
        liquidation_threshold: Arg1,
        liquidation_bonus: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addEModeCategory")
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_bonus)
            .original_result()
    }

    /// Edits an existing e-mode category’s parameters. 
    /// Updates risk settings for the category. 
    ///  
    /// # Arguments 
    /// - `category`: The updated `EModeCategory` struct. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    pub fn edit_e_mode_category<
        Arg0: ProxyArg<common_structs::EModeCategory<Env::Api>>,
    >(
        self,
        category: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editEModeCategory")
            .argument(&category)
            .original_result()
    }

    /// Removes an e-mode category by marking it as deprecated. 
    /// Disables the category for new positions. 
    ///  
    /// # Arguments 
    /// - `category_id`: ID of the e-mode category to remove. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    pub fn remove_e_mode_category<
        Arg0: ProxyArg<u8>,
    >(
        self,
        category_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeEModeCategory")
            .argument(&category_id)
            .original_result()
    }

    /// Adds an asset to an e-mode category with usage flags. 
    /// Configures collateral and borrowability in e-mode. 
    ///  
    /// # Arguments 
    /// - `asset`: Token identifier (EGLD or ESDT). 
    /// - `category_id`: E-mode category ID. 
    /// - `can_be_collateral`: Flag for collateral usability. 
    /// - `can_be_borrowed`: Flag for borrowability. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    /// - `ERROR_ASSET_NOT_SUPPORTED`: If the asset has no pool. 
    /// - `ERROR_ASSET_ALREADY_SUPPORTED_IN_EMODE`: If the asset is already in the category. 
    pub fn add_asset_to_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<bool>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
        can_be_collateral: Arg2,
        can_be_borrowed: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAssetToEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .original_result()
    }

    /// Edits an asset’s configuration within an e-mode category. 
    /// Updates usage flags for collateral or borrowing. 
    ///  
    /// # Arguments 
    /// - `asset`: Token identifier (EGLD or ESDT). 
    /// - `category_id`: E-mode category ID. 
    /// - `config`: New `EModeAssetConfig` settings. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    /// - `ERROR_ASSET_NOT_SUPPORTED_IN_EMODE`: If the asset is not in the category. 
    pub fn edit_asset_in_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<common_structs::EModeAssetConfig>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
        config: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editAssetInEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .argument(&config)
            .original_result()
    }

    /// Removes an asset from an e-mode category. 
    /// Disables the asset’s e-mode capabilities for the category. 
    ///  
    /// # Arguments 
    /// - `asset`: Token identifier (EGLD or ESDT). 
    /// - `category_id`: E-mode category ID. 
    ///  
    /// # Errors 
    /// - `ERROR_EMODE_CATEGORY_NOT_FOUND`: If the category ID does not exist. 
    /// - `ERROR_ASSET_NOT_SUPPORTED`: If the asset has no pool. 
    /// - `ERROR_ASSET_NOT_SUPPORTED_IN_EMODE`: If the asset is not in the category. 
    pub fn remove_asset_from_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAssetFromEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .original_result()
    }

    /// Edits an asset’s configuration in the protocol. 
    /// Updates risk parameters, usage flags, and caps. 
    ///  
    /// # Arguments 
    /// - `asset`: Token identifier (EGLD or ESDT). 
    /// - `loan_to_value`: New LTV in BPS. 
    /// - `liquidation_threshold`: New liquidation threshold in BPS. 
    /// - `liquidation_bonus`: New liquidation bonus in BPS. 
    /// - `liquidation_fees`: New liquidation fees in BPS. 
    /// - `is_isolated_asset`: Flag for isolated asset status. 
    /// - `isolation_debt_ceiling_usd`: Debt ceiling for isolated assets in USD. 
    /// - `is_siloed_borrowing`: Flag for siloed borrowing. 
    /// - `is_flashloanable`: Flag for flash loan support. 
    /// - `flashloan_fee`: Flash loan fee in BPS. 
    /// - `is_collateralizable`: Flag for collateral usability. 
    /// - `is_borrowable`: Flag for borrowability. 
    /// - `isolation_borrow_enabled`: Flag for borrowing in isolation mode. 
    /// - `borrow_cap`: New borrow cap (zero for no cap). 
    /// - `supply_cap`: New supply cap (zero for no cap). 
    ///  
    /// # Errors 
    /// - `ERROR_ASSET_NOT_SUPPORTED`: If the asset has no pool or config. 
    /// - `ERROR_INVALID_LIQUIDATION_THRESHOLD`: If threshold is not greater than LTV. 
    pub fn edit_asset_config<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<bool>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<bool>,
        Arg8: ProxyArg<bool>,
        Arg9: ProxyArg<BigUint<Env::Api>>,
        Arg10: ProxyArg<bool>,
        Arg11: ProxyArg<bool>,
        Arg12: ProxyArg<bool>,
        Arg13: ProxyArg<BigUint<Env::Api>>,
        Arg14: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        asset: Arg0,
        loan_to_value: Arg1,
        liquidation_threshold: Arg2,
        liquidation_bonus: Arg3,
        liquidation_fees: Arg4,
        is_isolated_asset: Arg5,
        isolation_debt_ceiling_usd: Arg6,
        is_siloed_borrowing: Arg7,
        is_flashloanable: Arg8,
        flashloan_fee: Arg9,
        is_collateralizable: Arg10,
        is_borrowable: Arg11,
        isolation_borrow_enabled: Arg12,
        borrow_cap: Arg13,
        supply_cap: Arg14,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editAssetConfig")
            .argument(&asset)
            .argument(&loan_to_value)
            .argument(&liquidation_threshold)
            .argument(&liquidation_bonus)
            .argument(&liquidation_fees)
            .argument(&is_isolated_asset)
            .argument(&isolation_debt_ceiling_usd)
            .argument(&is_siloed_borrowing)
            .argument(&is_flashloanable)
            .argument(&flashloan_fee)
            .argument(&is_collateralizable)
            .argument(&is_borrowable)
            .argument(&isolation_borrow_enabled)
            .argument(&borrow_cap)
            .argument(&supply_cap)
            .original_result()
    }

    /// Get the set of allowed pools 
    /// This storage mapper holds the addresses of pools that are allowed to participate in the lending protocol. 
    pub fn pools_allowed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolAllowed")
            .original_result()
    }

    /// Get the account token 
    /// This storage mapper holds the logic of the account token, which is a non-fungible token (NFT). 
    pub fn account_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountToken")
            .original_result()
    }

    /// Get the account positions 
    /// This storage mapper holds a list of account positions as a set. A position represents a nonce of an account (NFT nonce). 
    pub fn account_positions(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPositions")
            .original_result()
    }

    /// Get the account attributes 
    /// This storage mapper maps each minted NFT to account attributes, useful for retrieving attributes without having the NFT in hand. 
    pub fn account_attributes<
        Arg0: ProxyArg<u64>,
    >(
        self,
        nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AccountAttributes> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountAttributes")
            .argument(&nonce)
            .original_result()
    }

    /// Get the deposit positions 
    /// This storage mapper maps each deposit position to an account nonce, holding a list of assets and their corresponding structs. 
    pub fn deposit_positions<
        Arg0: ProxyArg<u64>,
    >(
        self,
        owner_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepositPositions")
            .argument(&owner_nonce)
            .original_result()
    }

    /// Get the borrow positions 
    /// This storage mapper maps each borrow position to an account nonce, holding a list of assets and their corresponding structs. 
    pub fn borrow_positions<
        Arg0: ProxyArg<u64>,
    >(
        self,
        owner_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowPositions")
            .argument(&owner_nonce)
            .original_result()
    }

    /// Get the liquidity pool template address 
    /// This storage mapper holds the address of the liquidity pool template, used to create new liquidity pools. 
    pub fn liq_pool_template_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiqPoolTemplateAddress")
            .original_result()
    }

    /// Get the accumulator address 
    /// This storage mapper holds the address of the accumulator, used to claim revenue from the liquidity pools. 
    pub fn accumulator_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccumulatorAddress")
            .original_result()
    }

    /// Get the pools map 
    /// This storage mapper holds a map of pools, used to get the address of a pool given a token ID. 
    pub fn pools_map<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolsMap")
            .argument(&asset)
            .original_result()
    }

    /// Get the price aggregator address 
    /// This storage mapper holds the address of the price aggregator, used to get the price of a token in USD. 
    pub fn price_aggregator_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceAggregatorAddress")
            .original_result()
    }

    /// Get the safe price view address 
    /// This storage mapper holds the address of the safe price view, used to get the price of a token out of the DEX pair. 
    pub fn safe_price_view(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePriceAddress")
            .original_result()
    }

    /// This storage mapper holds the address of the wrapper, used to convert between EGLD <-> WEGLD 
    pub fn wegld_wrapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEGLDWrapperAddress")
            .original_result()
    }

    pub fn aggregator(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAggregatorAddress")
            .original_result()
    }

    /// Get the asset config 
    /// This storage mapper holds the configuration of an asset, used to retrieve the config of an asset. 
    pub fn asset_config<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AssetConfig<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAssetConfig")
            .argument(&asset)
            .original_result()
    }

    /// Get the last e-mode category ID 
    /// This storage mapper holds the ID of the last e-mode category, used to retrieve the last e-mode category. 
    pub fn last_e_mode_category_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("lastEModeCategoryId")
            .original_result()
    }

    /// Get all e-mode categories 
    /// This storage mapper holds a map of e-mode categories, used to group assets into categories with different risk parameters. 
    pub fn e_mode_category(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<u8, common_structs::EModeCategory<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEModes")
            .original_result()
    }

    /// Get the e-mode categories for a given asset 
    /// This storage mapper holds a set of e-mode categories for a given asset. One asset can have multiple e-mode categories. 
    pub fn asset_e_modes<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u8>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAssetEModes")
            .argument(&asset)
            .original_result()
    }

    /// Get all assets for a given e-mode category 
    /// This storage mapper holds a map of assets for a given e-mode category, used to get the config for a given asset in a given e-mode category. 
    pub fn e_mode_assets<
        Arg0: ProxyArg<u8>,
    >(
        self,
        id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::EModeAssetConfig>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEModesAssets")
            .argument(&id)
            .original_result()
    }

    /// Get the debt in USD for isolated assets 
    /// This storage mapper holds the debt in USD for isolated assets. 
    pub fn isolated_asset_debt_usd<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getIsolatedAssetDebtUsd")
            .argument(&asset)
            .original_result()
    }

    /// Get the vault supplied amount per token 
    /// This storage mapper holds the supplied amount per token in the vault. 
    pub fn vault_supplied_amount<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getVaultSuppliedAmount")
            .argument(&asset)
            .original_result()
    }

    /// Get the token oracle 
    /// This storage mapper holds the oracle of a token, used to get the price of a token. 
    pub fn token_oracle<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::OracleProvider<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenOracle")
            .argument(&asset)
            .original_result()
    }

    /// Retrieves the liquidity pool address for a given asset. 
    /// Ensures the asset has an associated pool; errors if not found. 
    ///  
    /// # Arguments 
    /// - `asset`: The token identifier (EGLD or ESDT) of the asset. 
    ///  
    /// # Returns 
    /// - `ManagedAddress`: The address of the liquidity pool. 
    ///  
    /// # Errors 
    /// - `ERROR_NO_POOL_FOUND`: If no pool exists for the asset. 
    pub fn get_pool_address<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolAddress")
            .argument(&asset)
            .original_result()
    }

    /// Retrieves extended configuration views for multiple assets. 
    /// Includes market addresses and current prices in EGLD and USD. 
    ///  
    /// # Arguments 
    /// - `assets`: List of token identifiers (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - Vector of `AssetExtendedConfigView` structs for each asset. 
    pub fn get_all_markets<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, common_structs::AssetExtendedConfigView<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllMarkets")
            .argument(&assets)
            .original_result()
    }

    /// Determines if an account position is eligible for liquidation. 
    /// Checks if the health factor is below 1 (100% in WAD precision). 
    ///  
    /// # Arguments 
    /// - `account_position`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - `bool`: `true` if the position can be liquidated. 
    pub fn can_be_liquidated<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("canBeLiquidated")
            .argument(&account_position)
            .original_result()
    }

    /// Computes the current health factor for an account position. 
    /// Indicates position safety; lower values increase liquidation risk. 
    ///  
    /// # Arguments 
    /// - `account_position`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - Health factor as a `ManagedDecimal` in WAD precision. 
    pub fn get_health_factor<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHealthFactor")
            .argument(&account_position)
            .original_result()
    }

    /// Retrieves the collateral amount for a specific token in an account position. 
    /// Fails if the token is not part of the position’s collateral. 
    ///  
    /// # Arguments 
    /// - `account_position`: NFT nonce of the account position. 
    /// - `token_id`: Token identifier (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - Collateral amount as a `ManagedDecimal`. 
    ///  
    /// # Panics 
    /// - If the token is not in the account’s collateral. 
    pub fn get_collateral_amount_for_token<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account_position: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralAmountForToken")
            .argument(&account_position)
            .argument(&token_id)
            .original_result()
    }

    /// Retrieves the borrowed amount for a specific token in an account position. 
    /// Fails if the token is not part of the position’s borrows. 
    ///  
    /// # Arguments 
    /// - `account_position`: NFT nonce of the account position. 
    /// - `token_id`: Token identifier (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - Borrowed amount as a `ManagedDecimal`. 
    ///  
    /// # Panics 
    /// - If the token is not in the account’s borrows. 
    pub fn get_borrow_amount_for_token<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account_position: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowAmountForToken")
            .argument(&account_position)
            .argument(&token_id)
            .original_result()
    }

    /// Computes the total borrow value in EGLD for an account position. 
    /// Sums the EGLD value of all borrowed assets. 
    ///  
    /// # Arguments 
    /// - `account_position`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - Total borrow value in EGLD as a `ManagedDecimal`. 
    pub fn get_total_borrow_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrowInEgld")
            .argument(&account_position)
            .original_result()
    }

    /// Computes the total collateral value in EGLD for an account position. 
    /// Sums the EGLD value of all collateral assets (unweighted). 
    ///  
    /// # Arguments 
    /// - `account_position`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - Total collateral value in EGLD as a `ManagedDecimal`. 
    pub fn get_total_collateral_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalCollateralInEgld")
            .argument(&account_position)
            .original_result()
    }

    /// Computes the liquidation collateral available in EGLD. 
    /// Represents collateral value weighted by liquidation thresholds. 
    ///  
    /// # Arguments 
    /// - `account_nonce`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - Liquidation collateral in EGLD as a `ManagedDecimal`. 
    pub fn get_liquidation_collateral_available<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationCollateralAvailable")
            .argument(&account_nonce)
            .original_result()
    }

    /// Computes the LTV-weighted collateral value in EGLD. 
    /// Represents collateral value weighted by loan-to-value ratios. 
    ///  
    /// # Arguments 
    /// - `account_position`: NFT nonce of the account position. 
    ///  
    /// # Returns 
    /// - LTV-weighted collateral in EGLD as a `ManagedDecimal`. 
    pub fn get_ltv_collateral_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLtvCollateralInEgld")
            .argument(&account_position)
            .original_result()
    }

    /// Retrieves the USD price of a token using oracle data. 
    /// Converts the token’s EGLD price to USD for standardization. 
    ///  
    /// # Arguments 
    /// - `token_id`: Token identifier (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - USD price of the token as a `ManagedDecimal`. 
    pub fn get_usd_price<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenPriceUSD")
            .argument(&token_id)
            .original_result()
    }

    /// Retrieves the EGLD price of a token using oracle data. 
    /// Accesses the token’s price feed directly. 
    ///  
    /// # Arguments 
    /// - `token_id`: Token identifier (EGLD or ESDT) to query. 
    ///  
    /// # Returns 
    /// - EGLD price of the token as a `ManagedDecimal`. 
    pub fn get_egld_price<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenPriceEGLD")
            .argument(&token_id)
            .original_result()
    }

    pub fn multiply<
        Arg0: ProxyArg<u8>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg4: ProxyArg<OptionalValue<ManagedVec<Env::Api, AggregatorStep<Env::Api>>>>,
        Arg5: ProxyArg<OptionalValue<ManagedVec<Env::Api, TokenAmount<Env::Api>>>>,
    >(
        self,
        e_mode_category: Arg0,
        collateral_token: Arg1,
        final_collateral_amount: Arg2,
        debt_token: Arg3,
        steps: Arg4,
        limits: Arg5,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("multiply")
            .argument(&e_mode_category)
            .argument(&collateral_token)
            .argument(&final_collateral_amount)
            .argument(&debt_token)
            .argument(&steps)
            .argument(&limits)
            .original_result()
    }

    pub fn swap_collateral<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<OptionalValue<ManagedVec<Env::Api, AggregatorStep<Env::Api>>>>,
        Arg4: ProxyArg<OptionalValue<ManagedVec<Env::Api, TokenAmount<Env::Api>>>>,
    >(
        self,
        from_token: Arg0,
        from_amount: Arg1,
        to_token: Arg2,
        steps: Arg3,
        limits: Arg4,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("swapCollateral")
            .argument(&from_token)
            .argument(&from_amount)
            .argument(&to_token)
            .argument(&steps)
            .argument(&limits)
            .original_result()
    }

    pub fn swap_debt<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<OptionalValue<ManagedVec<Env::Api, AggregatorStep<Env::Api>>>>,
        Arg4: ProxyArg<OptionalValue<ManagedVec<Env::Api, TokenAmount<Env::Api>>>>,
    >(
        self,
        from_token: Arg0,
        from_amount: Arg1,
        to_token: Arg2,
        steps: Arg3,
        limits: Arg4,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("swapDebt")
            .argument(&from_token)
            .argument(&from_amount)
            .argument(&to_token)
            .argument(&steps)
            .argument(&limits)
            .original_result()
    }

    pub fn repay_debt_with_collateral<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<OptionalValue<ManagedVec<Env::Api, AggregatorStep<Env::Api>>>>,
        Arg4: ProxyArg<OptionalValue<ManagedVec<Env::Api, TokenAmount<Env::Api>>>>,
    >(
        self,
        from_token: Arg0,
        from_amount: Arg1,
        debt_token: Arg2,
        steps: Arg3,
        limits: Arg4,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("repayDebtWithCollateral")
            .argument(&from_token)
            .argument(&from_amount)
            .argument(&debt_token)
            .argument(&steps)
            .argument(&limits)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, ManagedVecItem)]
pub struct AggregatorStep<Api>
where
    Api: ManagedTypeApi,
{
    pub token_in: TokenIdentifier<Api>,
    pub token_out: TokenIdentifier<Api>,
    pub amount_in: BigUint<Api>,
    pub pool_address: ManagedAddress<Api>,
    pub function_name: ManagedBuffer<Api>,
    pub arguments: ManagedVec<Api, ManagedBuffer<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, ManagedVecItem)]
pub struct TokenAmount<Api>
where
    Api: ManagedTypeApi,
{
    pub token: TokenIdentifier<Api>,
    pub amount: BigUint<Api>,
}
