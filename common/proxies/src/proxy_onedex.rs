// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct OneDexProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for OneDexProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = OneDexProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        OneDexProxyMethods { wrapped_tx: tx }
    }
}

pub struct OneDexProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> OneDexProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        wegld_id: Arg0,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&wegld_id)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> OneDexProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> OneDexProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn set_config<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        treasury_address: Arg0,
        staking_reward_address: Arg1,
        burner_address: Arg2,
        unwrap_address: Arg3,
        registering_cost: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setConfig")
            .argument(&treasury_address)
            .argument(&staking_reward_address)
            .argument(&burner_address)
            .argument(&unwrap_address)
            .argument(&registering_cost)
            .original_result()
    }

    pub fn set_staking_reward_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        staking_reward_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakingRewardAddress")
            .argument(&staking_reward_address)
            .original_result()
    }

    pub fn set_treasury_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        treasury_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTreasuryAddress")
            .argument(&treasury_address)
            .original_result()
    }

    pub fn set_burner_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        burner_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBurnerAddress")
            .argument(&burner_address)
            .original_result()
    }

    pub fn set_unwrap_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        unwrap_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setUnwrapAddress")
            .argument(&unwrap_address)
            .original_result()
    }

    pub fn set_registering_cost<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        registering_cost: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRegisteringCost")
            .argument(&registering_cost)
            .original_result()
    }

    pub fn add_main_pair<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addMainPair")
            .argument(&token)
            .original_result()
    }

    pub fn remove_main_pair<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeMainPair")
            .argument(&token)
            .original_result()
    }

    ///     * Main Pair Tokens: <token_id, decimals>\n      
    pub fn main_pair_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMainPairTokens")
            .original_result()
    }

    ///     * Treasury Address\n     *  Address which Service fee will be transferred\n      
    pub fn treasury_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTreasuryAddreess")
            .original_result()
    }

    pub fn staking_reward_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingRewardAddress")
            .original_result()
    }

    pub fn burner_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBurnerAddreess")
            .original_result()
    }

    ///     * Unwrap Address\n     *  Shard 1 WrappedEgld SC Address\n      
    pub fn unwrap_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUnwrapAddreess")
            .original_result()
    }

    ///     * Registering Cost\n     *  cost: 2 EGLD\n      
    pub fn registering_cost(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRegisteringCost")
            .original_result()
    }

    ///     * Paused\n     *  true: not allowed to operate against sc\n     *  false: allowed\n      
    pub fn paused(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPaused")
            .original_result()
    }

    ///     * Pair Ids\n     *  (first_token_id, second_token_id) -> pair_id\n      
    pub fn pair_ids(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<(TokenIdentifier<Env::Api>, TokenIdentifier<Env::Api>), usize>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairIds")
            .original_result()
    }

    ///     * Last Pair Id\n      
    pub fn last_pair_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastPairId")
            .original_result()
    }

    ///     * Lp token_id -> pair_id\n      
    pub fn lp_token_pair_id_map(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<TokenIdentifier<Env::Api>, usize>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLpTokenPairIdMap")
            .original_result()
    }

    ///     * Pair Owner\n     *  pair_id -> owner address\n      
    pub fn pair_owner<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairOwner")
            .argument(&pair_id)
            .original_result()
    }

    ///     * State\n     *  pair_id -> Inactive or Active or ActiveButNoSwap\n      
    pub fn pair_state<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairState")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Enable Swap\n      
    pub fn pair_enabled<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairEnabled")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Pair first token_id\n     *  pair_id -> first token_id\n      
    pub fn pair_first_token_id<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairFirstTokenId")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Second token_id\n     *  pair_id -> second token_id\n      
    pub fn pair_second_token_id<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairSecondTokenId")
            .argument(&pair_id)
            .original_result()
    }

    ///     * First token Reserver\n      
    pub fn pair_first_token_reserve<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairFirstTokenReserve")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Second token Reserver\n      
    pub fn pair_second_token_reserve<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairSecondTokenReserve")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Lp Token Id\n      
    pub fn pair_lp_token_id<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairLpTokenId")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Lp Token Total Supply\n      
    pub fn pair_lp_token_supply<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairLpTokenTotalSupply")
            .argument(&pair_id)
            .original_result()
    }

    pub fn pair_fee<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, PairFee> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairFee")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Register as creator\n     *  Cost: 2 EGLD to enable swap\n      
    pub fn enable_swap<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enableSwap")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Create ESDT-ESDT pair\n     *  Constraint: Token Owner Only\n      
    pub fn create_pair<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<PairFee>,
    >(
        self,
        first_token_id: Arg0,
        second_token_id: Arg1,
        pair_fee: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, usize> {
        self.wrapped_tx
            .raw_call("createPair")
            .argument(&first_token_id)
            .argument(&second_token_id)
            .argument(&pair_fee)
            .original_result()
    }

    pub fn remove_pair<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        first_token_id: Arg0,
        second_token_id: Arg1,
        pair_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removePair")
            .argument(&first_token_id)
            .argument(&second_token_id)
            .argument(&pair_id)
            .original_result()
    }

    ///     * Issue Lp Token for pair\n      
    pub fn issue_lp_token<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issueLpToken")
            .argument(&pair_id)
            .original_result()
    }

    ///     * Set Local Role to mint or burn lp token\n      
    pub fn set_lp_token_local_roles<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLpTokenLocalRoles")
            .argument(&pair_id)
            .original_result()
    }

    pub fn issue_lp_token_and_set_roles<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        pair_id: Arg0,
        lp_token_display_name: Arg1,
        lp_token_ticker: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issueLpTokenAndSetRoles")
            .argument(&pair_id)
            .argument(&lp_token_display_name)
            .argument(&lp_token_ticker)
            .original_result()
    }

    pub fn whitelist_bonding_sc<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("whitelistBondingSc")
            .argument(&address)
            .original_result()
    }

    pub fn set_bonding_factory_sc_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBondingFactoryScAddress")
            .argument(&address)
            .original_result()
    }

    ///     * Active Pair\n      
    pub fn set_pair_active<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPairActive")
            .argument(&pair_id)
            .original_result()
    }

    ///     * No Swap Pair\n      
    pub fn set_pair_no_swaps<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPairActiveButNoSwap")
            .argument(&pair_id)
            .original_result()
    }

    pub fn set_pair_inactive<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPairInactive")
            .argument(&pair_id)
            .original_result()
    }

    pub fn set_pair_fee<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<PairFee>,
    >(
        self,
        pair_id: Arg0,
        pair_fee: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPairFee")
            .argument(&pair_id)
            .argument(&pair_fee)
            .original_result()
    }

    pub fn whitelisted_bonding(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedBonding")
            .original_result()
    }

    pub fn bonding_factory_sc_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBondingFactoryScAddress")
            .original_result()
    }

    ///     * Add initial liquidity\n     *  Pair owner could add initail liquidity\n      
    pub fn add_initial_liquidity(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addInitialLiquidity")
            .original_result()
    }

    ///     * Add Liquidity\n     *  anyone could add liquidity\n      
    pub fn add_liquidity<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        first_token_amount_min: Arg0,
        second_token_amount_min: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addLiquidity")
            .argument(&first_token_amount_min)
            .argument(&second_token_amount_min)
            .original_result()
    }

    ///     * Remove liquidity\n      
    pub fn remove_liquidity<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<bool>,
    >(
        self,
        first_token_amount_min: Arg0,
        second_token_amount_min: Arg1,
        unwrap_required: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("removeLiquidity")
            .argument(&first_token_amount_min)
            .argument(&second_token_amount_min)
            .argument(&unwrap_required)
            .original_result()
    }

    ///     * SWAP Fixed Input\n      
    pub fn swap_multi_tokens_fixed_input<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>>,
    >(
        self,
        amount_out_min: Arg0,
        unwrap_required: Arg1,
        path_args: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("swapMultiTokensFixedInput")
            .argument(&amount_out_min)
            .argument(&unwrap_required)
            .argument(&path_args)
            .original_result()
    }

    ///     * SWAP Fixed Output\n      
    pub fn swap_multi_tokens_fixed_output<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>>,
    >(
        self,
        amount_out_wanted: Arg0,
        unwrap_required: Arg1,
        path_args: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("swapMultiTokensFixedOutput")
            .argument(&amount_out_wanted)
            .argument(&unwrap_required)
            .argument(&path_args)
            .original_result()
    }

    pub fn get_equivalent<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_in: Arg0,
        token_out: Arg1,
        amount_in: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEquivalent")
            .argument(&token_in)
            .argument(&token_out)
            .argument(&amount_in)
            .original_result()
    }

    pub fn get_tokens_for_given_position<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_in: Arg0,
        token_out: Arg1,
        liquidity: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokensForGivenPosition")
            .argument(&token_in)
            .argument(&token_out)
            .argument(&liquidity)
            .original_result()
    }

    pub fn get_multi_path_amount_out<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>>,
    >(
        self,
        amount_in_arg: Arg0,
        path_args: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMultiPathAmountOut")
            .argument(&amount_in_arg)
            .argument(&path_args)
            .original_result()
    }

    pub fn get_amount_out_view<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_in: Arg0,
        token_out: Arg1,
        amount_in: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAmountOut")
            .argument(&token_in)
            .argument(&token_out)
            .argument(&amount_in)
            .original_result()
    }

    pub fn get_multi_path_amount_in<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>>,
    >(
        self,
        amount_out_wanted: Arg0,
        path_args: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMultiPathAmountIn")
            .argument(&amount_out_wanted)
            .argument(&path_args)
            .original_result()
    }

    pub fn get_amount_in_view<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_in: Arg0,
        token_wanted: Arg1,
        amount_wanted: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAmountIn")
            .argument(&token_in)
            .argument(&token_wanted)
            .argument(&amount_wanted)
            .original_result()
    }

    pub fn view_pairs(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, Pair<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("viewPairs")
            .original_result()
    }

    pub fn view_pairs_paginated<
        Arg0: ProxyArg<usize>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        offset: Arg0,
        limit: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, Pair<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("viewPairsPaginated")
            .argument(&offset)
            .argument(&limit)
            .original_result()
    }

    pub fn view_pair<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Pair<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("viewPair")
            .argument(&pair_id)
            .original_result()
    }

    pub fn safe_price_current_index<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pair_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePriceCurrentIndex")
            .argument(&pair_id)
            .original_result()
    }

    pub fn get_lp_tokens_safe_price_by_default_offset<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        lp_token_id: Arg0,
        liquidity: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLpTokensSafePriceByDefaultOffset")
            .argument(&lp_token_id)
            .argument(&liquidity)
            .original_result()
    }

    pub fn get_lp_tokens_safe_price_by_round_offset<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        lp_token_id: Arg0,
        round_offset: Arg1,
        liquidity: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLpTokensSafePriceByRoundOffset")
            .argument(&lp_token_id)
            .argument(&round_offset)
            .argument(&liquidity)
            .original_result()
    }

    pub fn get_lp_tokens_safe_price_by_timestamp_offset<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        lp_token_id: Arg0,
        timestamp_offset: Arg1,
        liquidity: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLpTokensSafePriceByTimestampOffset")
            .argument(&lp_token_id)
            .argument(&timestamp_offset)
            .argument(&liquidity)
            .original_result()
    }

    pub fn get_lp_tokens_safe_price<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        lp_token_id: Arg0,
        start_round: Arg1,
        end_round: Arg2,
        liquidity: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLpTokensSafePrice")
            .argument(&lp_token_id)
            .argument(&start_round)
            .argument(&end_round)
            .argument(&liquidity)
            .original_result()
    }

    pub fn get_safe_price_by_default_offset<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<EsdtTokenPayment<Env::Api>>,
    >(
        self,
        token_in: Arg0,
        token_out: Arg1,
        input_payment: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePriceByDefaultOffset")
            .argument(&token_in)
            .argument(&token_out)
            .argument(&input_payment)
            .original_result()
    }

    pub fn get_safe_price_by_round_offset<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<EsdtTokenPayment<Env::Api>>,
    >(
        self,
        token_in: Arg0,
        token_out: Arg1,
        round_offset: Arg2,
        input_payment: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePriceByRoundOffset")
            .argument(&token_in)
            .argument(&token_out)
            .argument(&round_offset)
            .argument(&input_payment)
            .original_result()
    }

    pub fn get_safe_price_by_timestamp_offset<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<EsdtTokenPayment<Env::Api>>,
    >(
        self,
        token_in: Arg0,
        token_out: Arg1,
        timestamp_offset: Arg2,
        input_payment: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePriceByTimestampOffset")
            .argument(&token_in)
            .argument(&token_out)
            .argument(&timestamp_offset)
            .argument(&input_payment)
            .original_result()
    }

    pub fn get_safe_price<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<u64>,
        Arg4: ProxyArg<EsdtTokenPayment<Env::Api>>,
    >(
        self,
        token_in: Arg0,
        token_out: Arg1,
        start_round: Arg2,
        end_round: Arg3,
        input_payment: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePrice")
            .argument(&token_in)
            .argument(&token_out)
            .argument(&start_round)
            .argument(&end_round)
            .argument(&input_payment)
            .original_result()
    }

    pub fn get_price_observation_view<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        token_in: Arg0,
        token_out: Arg1,
        search_round: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, PriceObservation<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceObservation")
            .argument(&token_in)
            .argument(&token_out)
            .argument(&search_round)
            .original_result()
    }
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq)]
pub enum State {
    Inactive,
    Active,
    ActiveButNoSwap,
}

#[type_abi]
#[derive(TopEncode, TopDecode, Copy, Clone, PartialEq, Debug)]
pub enum PairFee {
    Percent04,
    Percent06,
    Percent10,
}

#[type_abi]
#[derive(ManagedVecItem, TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct Pair<Api>
where
    Api: ManagedTypeApi,
{
    pub pair_id: usize,
    pub state: State,
    pub enabled: bool,
    pub owner: ManagedAddress<Api>,
    pub first_token_id: TokenIdentifier<Api>,
    pub second_token_id: TokenIdentifier<Api>,
    pub lp_token_id: TokenIdentifier<Api>,
    pub lp_token_decimal: usize,
    pub first_token_reserve: BigUint<Api>,
    pub second_token_reserve: BigUint<Api>,
    pub lp_token_supply: BigUint<Api>,
    pub lp_token_roles_are_set: bool,
    pub total_fee_percentage: u64,
}

#[type_abi]
#[derive(ManagedVecItem, Clone, TopEncode, TopDecode, NestedEncode, NestedDecode)]
pub struct PriceObservation<Api>
where
    Api: ManagedTypeApi,
{
    pub first_token_reserve_accumulated: BigUint<Api>,
    pub second_token_reserve_accumulated: BigUint<Api>,
    pub weight_accumulated: u64,
    pub recording_round: u64,
    pub lp_supply_accumulated: BigUint<Api>,
}
