// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LendingPoolProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LendingPoolProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LendingPoolProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LendingPoolProxyMethods { wrapped_tx: tx }
    }
}

pub struct LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LendingPoolProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the lending pool contract 
    ///  
    /// # Arguments 
    /// * `lp_template_address` - Address of the liquidity pool template contract 
    /// * `aggregator` - Address of the price aggregator contract 
    /// * `safe_view_address` - Address of the safe price view contract 
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        lp_template_address: Arg0,
        aggregator: Arg1,
        safe_view_address: Arg2,
        accumulator_address: Arg3,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&lp_template_address)
            .argument(&aggregator)
            .argument(&safe_view_address)
            .argument(&accumulator_address)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Supplies collaterals to the lending pool 
    ///  
    /// # Arguments 
    /// * `is_vault` - Whether this supply is for a vault position 
    /// * `e_mode_category` - Optional e-mode category to use 
    ///  
    /// # Payment 
    /// Accepts 1-2 ESDT payments: 
    /// - Optional account NFT (if user has an existing position) 
    /// - Collateral token to supply 
    ///  
    /// # Flow 
    /// 1. Validates payments and extracts tokens 
    /// 2. Gets/creates position and NFT attributes, returns NFT to owner 
    /// 3. Validates e-mode constraints 
    /// 4. Validates vault consistency 
    /// 5. Validates isolated collateral rules 
    /// 6. Checks supply caps 
    /// 7. Updates position 
    /// 8. Emits event 
    ///  
    /// ``` 
    pub fn supply<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<OptionalValue<u8>>,
    >(
        self,
        is_vault: Arg0,
        e_mode_category: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("supply")
            .argument(&is_vault)
            .argument(&e_mode_category)
            .original_result()
    }

    /// Withdraws collateral from the lending pool 
    ///  
    /// # Arguments 
    /// * `withdraw_token_id` - Token identifier to withdraw 
    /// * `amount` - Amount to withdraw 
    ///  
    /// # Payment 
    /// Requires account NFT payment 
    ///  
    /// # Flow 
    /// 1. Validates payment and parameters 
    /// 2. Processes withdrawal 
    /// 3. Validates health factor after withdrawal 
    /// 4. Handles NFT (burns or returns) 
    ///  
    /// ``` 
    pub fn withdraw<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>>,
    >(
        self,
        collaterals: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("withdraw")
            .argument(&collaterals)
            .original_result()
    }

    /// Borrows an asset from the lending pool 
    ///  
    /// # Arguments 
    /// * `asset_to_borrow` - Token identifier to borrow 
    /// * `amount` - Amount to borrow 
    ///  
    /// # Payment 
    /// Requires account NFT payment 
    ///  
    /// # Flow 
    /// 1. Validates payment and parameters 
    /// 2. Gets NFT attributes and asset config 
    /// 3. Updates positions with latest interest 
    /// 4. Validates borrowing constraints 
    /// 5. Checks borrow cap 
    /// 6. Validates collateral sufficiency 
    /// 7. Processes borrow 
    /// 8. Emits event 
    /// 9. Returns NFT 
    ///  
    /// # Example 
    /// ``` 
    /// // Borrow 1000 USDC using account NFT 
    /// ESDTTransfer { 
    ///   token: "LEND-123456", // Account NFT 
    ///   nonce: 1, 
    ///   amount: 1 
    /// } 
    /// borrow("USDC-123456", 1_000_000_000) // 1000 USDC 
    /// ``` 
    pub fn borrow<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenPayment<Env::Api>>>,
    >(
        self,
        borrowed_tokens: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("borrow")
            .argument(&borrowed_tokens)
            .original_result()
    }

    /// Repays borrowed assets 
    ///  
    /// # Arguments 
    /// * `account_nonce` - NFT nonce of the account position to repay 
    /// ``` 
    pub fn repay<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("repay")
            .argument(&account_nonce)
            .original_result()
    }

    /// Liquidates an unhealthy position 
    ///  
    /// # Arguments 
    /// * `liquidatee_account_nonce` - NFT nonce of the account to liquidate 
    /// * `collateral_to_receive` - Token identifier of collateral to receive 
    ///  
    /// # Payment 
    /// Accepts EGLD or single ESDT payment of the debt token 
    ///  
    /// # Flow 
    /// 1. Validates payment and parameters 
    /// 2. Processes liquidation: 
    ///    - Calculates liquidation amounts 
    ///    - Updates positions 
    ///    - Transfers tokens 
    ///    - Emits events 
    ///  
    /// ``` 
    pub fn liquidate<
        Arg0: ProxyArg<u64>,
    >(
        self,
        liquidatee_account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("liquidate")
            .argument(&liquidatee_account_nonce)
            .original_result()
    }

    /// Executes a flash loan 
    ///  
    /// # Arguments 
    /// * `borrowed_token` - Token identifier to borrow 
    /// * `amount` - Amount to borrow 
    /// * `contract_address` - Address of contract to receive funds 
    /// * `endpoint` - Endpoint to call on receiving contract 
    /// * `arguments` - Arguments to pass to endpoint 
    ///  
    /// # Flow 
    /// 1. Validates flash loan is enabled for asset 
    /// 2. Validates contract is on same shard 
    /// 3. Executes flash loan through pool: 
    ///    - Transfers tokens to contract 
    ///    - Calls specified endpoint 
    ///    - Verifies repayment with fee 
    ///  
    ///  
    pub fn flash_loan<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<ManagedArgBuffer<Env::Api>>,
    >(
        self,
        borrowed_token: Arg0,
        amount: Arg1,
        contract_address: Arg2,
        endpoint: Arg3,
        arguments: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("flashLoan")
            .argument(&borrowed_token)
            .argument(&amount)
            .argument(&contract_address)
            .argument(&endpoint)
            .argument(&arguments)
            .original_result()
    }

    /// Synchronizes account positions with latest interest rates 
    ///  
    /// # Arguments 
    /// * `account_nonce` - NFT nonce of the account to sync 
    ///  
    /// # Returns 
    /// * `MultiValue2<ManagedVec<AccountPosition>, ManagedVec<AccountPosition>>` 
    ///   - Updated deposit positions 
    ///   - Updated borrow positions 
    ///  
    /// # Flow 
    /// 1. Validates account exists 
    /// 2. Updates borrow positions with accumulated interest 
    /// 3. Updates deposit positions with accumulated interest 
    ///  
    /// # Example 
    /// ``` 
    /// let (deposits, borrows) = updateAccountPositions(1); 
    /// // deposits and borrows contain updated position data 
    /// ``` 
    pub fn update_account_positions<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<ManagedVec<Env::Api, common_structs::AccountPosition<Env::Api>>, ManagedVec<Env::Api, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountPositions")
            .argument(&account_nonce)
            .original_result()
    }

    /// Disables vault for a given account that has vault enabled 
    /// # Arguments 
    /// * `account_nonce` - NFT nonce of the account to disable vault for 
    ///  
    /// # Flow 
    /// 1. Validates account exists 
    /// 2. Validates account token 
    /// 3. Iterates over borrow positions 
    /// 4. Disables vault for each borrow position 
    /// 5. Iterates over deposit positions 
    /// 6. Disables vault for each deposit position and move funds to the market shared pool 
    /// 7. Emits event for each position 
    ///  
    /// ``` 
    pub fn disable_vault(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("disableVault")
            .original_result()
    }

    /// Enables vault for a given account that has vault disabled 
    /// # Arguments 
    /// * `account_nonce` - NFT nonce of the account to enable vault for 
    ///  
    /// # Flow 
    /// 1. Validates account exists 
    /// 2. Validates account token 
    /// 3. Iterates over borrow positions 
    /// 4. Enables vault for each borrow position 
    /// 5. Iterates over deposit positions 
    /// 6. Enables vault for each deposit position and move funds from shared pool to the controller vault 
    /// 7. Emits event for each position 
    ///  
    pub fn enable_vault(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("enableVault")
            .original_result()
    }

    /// Updates the LTV for a given asset and account positions 
    ///  
    /// # Arguments 
    /// * `token_id` - Token identifier to update LTV for 
    /// * `account_nonces` - Nonces of the accounts to update LTV for 
    ///  
    /// # Flow 
    /// 1. Validates asset is supported 
    /// 2. Iterates over account positions 
    /// 3. Updates LTV if necessary 
    /// 4. Emits event if LTV is updated 
    pub fn update_position_threshold<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<MultiValueEncoded<Env::Api, u64>>,
    >(
        self,
        token_id: Arg0,
        is_ltv: Arg1,
        account_nonces: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updatePositionThreshold")
            .argument(&token_id)
            .argument(&is_ltv)
            .argument(&account_nonces)
            .original_result()
    }

    /// Updates interest rate indexes for a given asset 
    ///  
    /// # Arguments 
    /// * `token_id` - Token identifier to update indexes for 
    ///  
    /// # Flow 
    /// 1. Gets pool address for token 
    /// 2. Gets current asset price 
    /// 3. Calls pool to update indexes with current price 
    pub fn update_indexes<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateIndexes")
            .argument(&assets)
            .original_result()
    }

    pub fn create_liquidity_pool<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
        Arg9: ProxyArg<BigUint<Env::Api>>,
        Arg10: ProxyArg<BigUint<Env::Api>>,
        Arg11: ProxyArg<bool>,
        Arg12: ProxyArg<bool>,
        Arg13: ProxyArg<bool>,
        Arg14: ProxyArg<BigUint<Env::Api>>,
        Arg15: ProxyArg<BigUint<Env::Api>>,
        Arg16: ProxyArg<bool>,
        Arg17: ProxyArg<bool>,
        Arg18: ProxyArg<bool>,
        Arg19: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
        Arg20: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        base_asset: Arg0,
        r_max: Arg1,
        r_base: Arg2,
        r_slope1: Arg3,
        r_slope2: Arg4,
        u_optimal: Arg5,
        reserve_factor: Arg6,
        ltv: Arg7,
        liquidation_threshold: Arg8,
        liquidation_base_bonus: Arg9,
        liquidation_max_fee: Arg10,
        can_be_collateral: Arg11,
        can_be_borrowed: Arg12,
        is_isolated: Arg13,
        debt_ceiling_usd: Arg14,
        flash_loan_fee: Arg15,
        is_siloed: Arg16,
        flashloan_enabled: Arg17,
        can_borrow_in_isolation: Arg18,
        borrow_cap: Arg19,
        supply_cap: Arg20,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createLiquidityPool")
            .argument(&base_asset)
            .argument(&r_max)
            .argument(&r_base)
            .argument(&r_slope1)
            .argument(&r_slope2)
            .argument(&u_optimal)
            .argument(&reserve_factor)
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_base_bonus)
            .argument(&liquidation_max_fee)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .argument(&is_isolated)
            .argument(&debt_ceiling_usd)
            .argument(&flash_loan_fee)
            .argument(&is_siloed)
            .argument(&flashloan_enabled)
            .argument(&can_borrow_in_isolation)
            .argument(&borrow_cap)
            .argument(&supply_cap)
            .original_result()
    }

    pub fn upgrade_liquidity_pool<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        base_asset: Arg0,
        r_max: Arg1,
        r_base: Arg2,
        r_slope1: Arg3,
        r_slope2: Arg4,
        u_optimal: Arg5,
        reserve_factor: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("upgradeLiquidityPool")
            .argument(&base_asset)
            .argument(&r_max)
            .argument(&r_base)
            .argument(&r_slope1)
            .argument(&r_slope2)
            .argument(&u_optimal)
            .argument(&reserve_factor)
            .original_result()
    }

    /// Claim revenue from the accumulator 
    ///  
    /// This function is used to claim the revenue from the liquidity pools 
    /// It iterates over the markets and claims the revenue 
    /// The revenue is deposited into the accumulator 
    pub fn claim_revenue<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        assets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRevenue")
            .argument(&assets)
            .original_result()
    }

    pub fn register_account_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        token_name: Arg0,
        ticker: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("registerAccountToken")
            .argument(&token_name)
            .argument(&ticker)
            .original_result()
    }

    pub fn set_token_oracle<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<common_structs::PricingMethod>,
        Arg4: ProxyArg<common_structs::OracleType>,
        Arg5: ProxyArg<common_structs::ExchangeSource>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        market_token: Arg0,
        decimals: Arg1,
        contract_address: Arg2,
        pricing_method: Arg3,
        token_type: Arg4,
        source: Arg5,
        first_tolerance: Arg6,
        last_tolerance: Arg7,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTokenOracle")
            .argument(&market_token)
            .argument(&decimals)
            .argument(&contract_address)
            .argument(&pricing_method)
            .argument(&token_type)
            .argument(&source)
            .argument(&first_tolerance)
            .argument(&last_tolerance)
            .original_result()
    }

    pub fn edit_token_oracle_tolerance<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        market_token: Arg0,
        first_tolerance: Arg1,
        last_tolerance: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editTokenOracleTolerance")
            .argument(&market_token)
            .argument(&first_tolerance)
            .argument(&last_tolerance)
            .original_result()
    }

    pub fn set_aggregator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        aggregator: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAggregator")
            .argument(&aggregator)
            .original_result()
    }

    pub fn set_accumulator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        accumulator: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAccumulator")
            .argument(&accumulator)
            .original_result()
    }

    pub fn set_safe_price_view<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        safe_view_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSafePriceView")
            .argument(&safe_view_address)
            .original_result()
    }

    pub fn set_liquidity_pool_template<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidityPoolTemplate")
            .argument(&address)
            .original_result()
    }

    pub fn add_e_mode_category<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ltv: Arg0,
        liquidation_threshold: Arg1,
        liquidation_bonus: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addEModeCategory")
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_bonus)
            .original_result()
    }

    pub fn edit_e_mode_category<
        Arg0: ProxyArg<common_structs::EModeCategory<Env::Api>>,
    >(
        self,
        category: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editEModeCategory")
            .argument(&category)
            .original_result()
    }

    pub fn remove_e_mode_category<
        Arg0: ProxyArg<u8>,
    >(
        self,
        category_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeEModeCategory")
            .argument(&category_id)
            .original_result()
    }

    pub fn add_asset_to_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<bool>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
        can_be_collateral: Arg2,
        can_be_borrowed: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAssetToEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .original_result()
    }

    pub fn edit_asset_in_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<common_structs::EModeAssetConfig>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
        config: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editAssetInEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .argument(&config)
            .original_result()
    }

    pub fn remove_asset_from_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAssetFromEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .original_result()
    }

    pub fn edit_asset_config<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<bool>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<bool>,
        Arg8: ProxyArg<bool>,
        Arg9: ProxyArg<BigUint<Env::Api>>,
        Arg10: ProxyArg<bool>,
        Arg11: ProxyArg<bool>,
        Arg12: ProxyArg<bool>,
        Arg13: ProxyArg<BigUint<Env::Api>>,
        Arg14: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        asset: Arg0,
        ltv: Arg1,
        liquidation_threshold: Arg2,
        liquidation_base_bonus: Arg3,
        liquidation_max_fee: Arg4,
        is_isolated: Arg5,
        debt_ceiling_usd: Arg6,
        is_siloed: Arg7,
        flashloan_enabled: Arg8,
        flash_loan_fee: Arg9,
        can_be_collateral: Arg10,
        can_be_borrowed: Arg11,
        can_borrow_in_isolation: Arg12,
        borrow_cap: Arg13,
        supply_cap: Arg14,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editAssetConfig")
            .argument(&asset)
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_base_bonus)
            .argument(&liquidation_max_fee)
            .argument(&is_isolated)
            .argument(&debt_ceiling_usd)
            .argument(&is_siloed)
            .argument(&flashloan_enabled)
            .argument(&flash_loan_fee)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .argument(&can_borrow_in_isolation)
            .argument(&borrow_cap)
            .argument(&supply_cap)
            .original_result()
    }

    /// Get the set of allowed pools 
    /// This storage mapper holds the addresses of pools that are allowed to participate in the lending protocol. 
    pub fn pools_allowed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolAllowed")
            .original_result()
    }

    /// Get the account token 
    /// This storage mapper holds the logic of the account token, which is a non-fungible token (NFT). 
    pub fn account_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountToken")
            .original_result()
    }

    /// Get the account positions 
    /// This storage mapper holds a list of account positions as a set. A position represents a nonce of an account (NFT nonce). 
    pub fn account_positions(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPositions")
            .original_result()
    }

    /// Get the account attributes 
    /// This storage mapper maps each minted NFT to account attributes, useful for retrieving attributes without having the NFT in hand. 
    pub fn account_attributes<
        Arg0: ProxyArg<u64>,
    >(
        self,
        nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::NftAccountAttributes> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountAttributes")
            .argument(&nonce)
            .original_result()
    }

    /// Get the deposit positions 
    /// This storage mapper maps each deposit position to an account nonce, holding a list of assets and their corresponding structs. 
    pub fn deposit_positions<
        Arg0: ProxyArg<u64>,
    >(
        self,
        owner_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepositPositions")
            .argument(&owner_nonce)
            .original_result()
    }

    /// Get the borrow positions 
    /// This storage mapper maps each borrow position to an account nonce, holding a list of assets and their corresponding structs. 
    pub fn borrow_positions<
        Arg0: ProxyArg<u64>,
    >(
        self,
        owner_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowPositions")
            .argument(&owner_nonce)
            .original_result()
    }

    /// Get the liquidity pool template address 
    /// This storage mapper holds the address of the liquidity pool template, used to create new liquidity pools. 
    pub fn liq_pool_template_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiqPoolTemplateAddress")
            .original_result()
    }

    /// Get the accumulator address 
    /// This storage mapper holds the address of the accumulator, used to claim revenue from the liquidity pools. 
    pub fn accumulator_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccumulatorAddress")
            .original_result()
    }

    /// Get the pools map 
    /// This storage mapper holds a map of pools, used to get the address of a pool given a token ID. 
    pub fn pools_map<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolsMap")
            .argument(&token_id)
            .original_result()
    }

    /// Get the price aggregator address 
    /// This storage mapper holds the address of the price aggregator, used to get the price of a token in USD. 
    pub fn price_aggregator_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceAggregatorAddress")
            .original_result()
    }

    /// Get the safe price view address 
    /// This storage mapper holds the address of the safe price view, used to get the price of a token out of the DEX pair. 
    pub fn safe_price_view(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePriceView")
            .original_result()
    }

    /// Get the asset config 
    /// This storage mapper holds the configuration of an asset, used to retrieve the config of an asset. 
    pub fn asset_config<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AssetConfig<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAssetConfig")
            .argument(&asset)
            .original_result()
    }

    /// Get the last e-mode category ID 
    /// This storage mapper holds the ID of the last e-mode category, used to retrieve the last e-mode category. 
    pub fn last_e_mode_category_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("lastEModeCategoryId")
            .original_result()
    }

    /// Get all e-mode categories 
    /// This storage mapper holds a map of e-mode categories, used to group assets into categories with different risk parameters. 
    pub fn e_mode_category(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<u8, common_structs::EModeCategory<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEModes")
            .original_result()
    }

    /// Get the e-mode categories for a given asset 
    /// This storage mapper holds a set of e-mode categories for a given asset. One asset can have multiple e-mode categories. 
    pub fn asset_e_modes<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u8>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAssetEModes")
            .argument(&asset)
            .original_result()
    }

    /// Get all assets for a given e-mode category 
    /// This storage mapper holds a map of assets for a given e-mode category, used to get the config for a given asset in a given e-mode category. 
    pub fn e_mode_assets<
        Arg0: ProxyArg<u8>,
    >(
        self,
        id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::EModeAssetConfig>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEModesAssets")
            .argument(&id)
            .original_result()
    }

    /// Get the debt in USD for isolated assets 
    /// This storage mapper holds the debt in USD for isolated assets. 
    pub fn isolated_asset_debt_usd<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getIsolatedAssetDebtUsd")
            .argument(&token_id)
            .original_result()
    }

    /// Get the vault supplied amount per token 
    /// This storage mapper holds the supplied amount per token in the vault. 
    pub fn vault_supplied_amount<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getVaultSuppliedAmount")
            .argument(&token_id)
            .original_result()
    }

    /// Get the token oracle 
    /// This storage mapper holds the oracle of a token, used to get the price of a token. 
    pub fn token_oracle<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::OracleProvider<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenOracle")
            .argument(&token_id)
            .original_result()
    }

    /// Gets the liquidity pool address for a given asset 
    ///  
    /// # Arguments 
    /// * `asset` - Token identifier of the asset 
    ///  
    /// # Returns 
    /// * `ManagedAddress` - Address of the liquidity pool 
    ///  
    /// # Errors 
    /// * `ERROR_NO_POOL_FOUND` - If no pool exists for the asset 
    pub fn get_pool_address<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolAddress")
            .argument(&asset)
            .original_result()
    }

    pub fn get_all_markets<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
    >(
        self,
        tokens: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, common_structs::AssetExtendedConfigView<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAllMarkets")
            .argument(&tokens)
            .original_result()
    }

    /// Checks if an account position can be liquidated 
    ///  
    /// # Arguments 
    /// * `account_position` - NFT nonce of the account position 
    ///  
    /// # Returns 
    /// * `bool` - True if position can be liquidated (health factor < 100%) 
    ///  
    /// # Example 
    /// ``` 
    /// // Position 1: Healthy 
    /// // Collateral: $150 weighted 
    /// // Borrows: $100 
    /// // Health Factor: 150% (15000 bp) 
    /// can_be_liquidated(1) = false 
    ///  
    /// // Position 2: Unhealthy 
    /// // Collateral: $90 weighted 
    /// // Borrows: $100 
    /// // Health Factor: 90% (9000 bp) 
    /// can_be_liquidated(2) = true 
    /// ``` 
    pub fn can_be_liquidated<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("canBeLiquidated")
            .argument(&account_position)
            .original_result()
    }

    /// Gets the current health factor for an account position 
    ///  
    /// # Arguments 
    /// * `account_position` - NFT nonce of the account position 
    ///  
    /// # Returns 
    /// * `BigUint` - Health factor in basis points (10000 = 100%) 
    ///  
    /// # Example 
    /// ``` 
    /// // Position with: 
    /// // Collateral: 100 EGLD @ $100 each = $10,000 
    /// // Liquidation threshold: 80% 
    /// // Weighted collateral: $8,000 
    ///  
    /// // Borrows: 5000 USDC @ $1 each = $5,000 
    ///  
    /// // Health Factor = $8,000 * 10000 / $5,000 = 16000 (160%) 
    /// get_health_factor(1) = 16000 
    /// ``` 
    pub fn get_health_factor<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHealthFactor")
            .argument(&account_position)
            .original_result()
    }

    /// Calculates maximum amount of collateral that can be liquidated 
    ///  
    /// # Arguments 
    /// * `account_position` - NFT nonce of the account position 
    /// * `collateral_asset` - Token identifier of collateral to liquidate 
    /// * `in_usd` - Whether to return amount in USD (true) or token units (false) 
    ///  
    /// # Returns 
    /// * `BigUint` - Maximum liquidatable amount in USD or token units 
    ///  
    /// # Errors 
    /// * `ERROR_HEALTH_FACTOR` - If position is not liquidatable (HF >= 100%) 
    ///  
    /// # Example 
    /// ``` 
    /// // Position: 
    /// // Collateral: 100 EGLD @ $100 each = $10,000 
    /// // Borrows: 9000 USDC @ $1 each = $9,000 
    /// // Health Factor: 90% (unhealthy) 
    /// // Liquidation Bonus: 10% 
    ///  
    /// // In USD: 
    /// get_max_liquidate_amount_for_collateral(1, "EGLD-123456", true) = 5000 
    /// // Can liquidate $5,000 worth of collateral 
    ///  
    /// // In EGLD: 
    /// get_max_liquidate_amount_for_collateral(1, "EGLD-123456", false) = 50 
    /// // Can liquidate 50 EGLD 
    /// ``` 
    /// Gets the collateral amount for a specific token 
    ///  
    /// # Arguments 
    /// * `account_position` - NFT nonce of the account position 
    /// * `token_id` - Token identifier to check 
    ///  
    /// # Returns 
    /// * `BigUint` - Amount of token supplied as collateral 
    ///  
    /// # Example 
    /// ``` 
    /// // Position has: 
    /// // - 100 EGLD supplied 
    /// // - 1000 USDC supplied 
    ///  
    /// get_collateral_amount_for_token(1, "EGLD-123456") = 100_000_000_000_000_000_000 
    /// get_collateral_amount_for_token(1, "USDC-123456") = 1_000_000_000 
    /// get_collateral_amount_for_token(1, "USDT-123456") = 0 // No USDT supplied 
    /// ``` 
    pub fn get_collateral_amount_for_token<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account_position: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralAmountForToken")
            .argument(&account_position)
            .argument(&token_id)
            .original_result()
    }

    /// Gets the borrowed amount for a specific token 
    ///  
    /// # Arguments 
    /// * `account_position` - NFT nonce of the account position 
    /// * `token_id` - Token identifier to check 
    ///  
    /// # Returns 
    /// * `BigUint` - Amount of token borrowed 
    ///  
    /// # Example 
    /// ``` 
    /// // Position has: 
    /// // - 50 EGLD borrowed 
    /// // - 500 USDC borrowed 
    ///  
    /// get_borrow_amount_for_token(1, "EGLD-123456") = 50_000_000_000_000_000_000 
    /// get_borrow_amount_for_token(1, "USDC-123456") = 500_000_000 
    /// get_borrow_amount_for_token(1, "USDT-123456") = 0 // No USDT borrowed 
    /// ``` 
    pub fn get_borrow_amount_for_token<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account_position: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowAmountForToken")
            .argument(&account_position)
            .argument(&token_id)
            .original_result()
    }

    /// Gets total value of borrowed assets in USD 
    ///  
    /// # Arguments 
    /// * `account_position` - NFT nonce of the account position 
    ///  
    /// # Returns 
    /// * `BigUint` - Total USD value of all borrowed assets 
    ///  
    /// # Example 
    /// ``` 
    /// // Position has: 
    /// // - 50 EGLD borrowed @ $100 each = $5,000 
    /// // - 500 USDC borrowed @ $1 each = $500 
    ///  
    /// get_total_borrow_in_egld(1) = 5_500_000_000 // $5,500 
    /// ``` 
    pub fn get_total_borrow_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrowInEgld")
            .argument(&account_position)
            .original_result()
    }

    /// Gets total value of collateral assets in USD 
    ///  
    /// # Arguments 
    /// * `account_position` - NFT nonce of the account position 
    ///  
    /// # Returns 
    /// * `BigUint` - Total USD value of all collateral assets (unweighted) 
    ///  
    /// # Example 
    /// ``` 
    /// // Position has: 
    /// // - 100 EGLD supplied @ $100 each = $10,000 
    /// // - 1000 USDC supplied @ $1 each = $1,000 
    ///  
    /// get_total_collateral_in_dollars(1) = 11_000_000_000 // $11,000 
    /// ``` 
    pub fn get_total_collateral_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalCollateralInEgld")
            .argument(&account_position)
            .original_result()
    }

    /// Gets total value of collateral available for liquidation in USD 
    ///  
    /// # Arguments 
    /// * `account_nonce` - NFT nonce of the account position 
    ///  
    /// # Returns 
    /// * `BigUint` - Total USD value of collateral weighted by liquidation thresholds 
    ///  
    /// # Example 
    /// ``` 
    /// // Position has: 
    /// // - 100 EGLD @ $100 each = $10,000, threshold 80% = $8,000 
    /// // - 1000 USDC @ $1 each = $1,000, threshold 85% = $850 
    ///  
    /// get_liquidation_collateral_available(1) = 8_850_000_000 // $8,850 
    /// ``` 
    pub fn get_liquidation_collateral_available<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationCollateralAvailable")
            .argument(&account_nonce)
            .original_result()
    }

    /// Gets total value of collateral weighted by LTV ratios in USD 
    ///  
    /// # Arguments 
    /// * `account_position` - NFT nonce of the account position 
    ///  
    /// # Returns 
    /// * `BigUint` - Total USD value of collateral weighted by LTV ratios 
    ///  
    /// # Example 
    /// ``` 
    /// // Position has: 
    /// // - 100 EGLD @ $100 each = $10,000, LTV 75% = $7,500 
    /// // - 1000 USDC @ $1 each = $1,000, LTV 80% = $800 
    ///  
    /// get_ltv_collateral_in_dollars(1) = 8_300_000_000 // $8,300 
    /// ``` 
    pub fn get_ltv_collateral_in_egld<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLtvCollateralInEgld")
            .argument(&account_position)
            .original_result()
    }

    pub fn get_token_price_data_view<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::PriceFeedShort<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenPriceData")
            .argument(&token_id)
            .original_result()
    }

    pub fn get_usd_price<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenPriceUSD")
            .argument(&token_id)
            .original_result()
    }

    pub fn get_egld_price<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenPriceEGLD")
            .argument(&token_id)
            .original_result()
    }

    pub fn calculate_max_leverage<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<Option<common_structs::EModeCategory<Env::Api>>>,
        Arg3: ProxyArg<common_structs::AssetConfig<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        initial_deposit: Arg0,
        health_factor: Arg1,
        e_mode: Arg2,
        asset_config: Arg3,
        total_reserves: Arg4,
        reserve_buffer: Arg5,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxLeverage")
            .argument(&initial_deposit)
            .argument(&health_factor)
            .argument(&e_mode)
            .argument(&asset_config)
            .argument(&total_reserves)
            .argument(&reserve_buffer)
            .original_result()
    }
}
