// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LendingPoolProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LendingPoolProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LendingPoolProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LendingPoolProxyMethods { wrapped_tx: tx }
    }
}

pub struct LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LendingPoolProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        lp_template_address: Arg0,
        aggregator: Arg1,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&lp_template_address)
            .argument(&aggregator)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LendingPoolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn supply<
        Arg0: ProxyArg<OptionalValue<u8>>,
    >(
        self,
        e_mode_category: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("supply")
            .argument(&e_mode_category)
            .original_result()
    }

    pub fn withdraw<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        withdraw_token_id: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("withdraw")
            .argument(&withdraw_token_id)
            .argument(&amount)
            .original_result()
    }

    pub fn borrow<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        asset_to_borrow: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("borrow")
            .argument(&asset_to_borrow)
            .argument(&amount)
            .original_result()
    }

    pub fn repay<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("repay")
            .argument(&account_nonce)
            .original_result()
    }

    pub fn liquidate<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        liquidatee_account_nonce: Arg0,
        collateral_to_receive: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("liquidate")
            .argument(&liquidatee_account_nonce)
            .argument(&collateral_to_receive)
            .original_result()
    }

    pub fn flash_loan<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<ManagedArgBuffer<Env::Api>>,
    >(
        self,
        borrowed_token: Arg0,
        amount: Arg1,
        contract_address: Arg2,
        endpoint: Arg3,
        arguments: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("flashLoan")
            .argument(&borrowed_token)
            .argument(&amount)
            .argument(&contract_address)
            .argument(&endpoint)
            .argument(&arguments)
            .original_result()
    }

    pub fn update_collateral_with_interest<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, common_structs::AccountPosition<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updatePositionInterest")
            .argument(&account_position)
            .original_result()
    }

    pub fn update_borrows_with_debt<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, common_structs::AccountPosition<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updatePositionDebt")
            .argument(&account_position)
            .original_result()
    }

    pub fn liq_pool_template_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiqPoolTemplateAddress")
            .original_result()
    }

    pub fn create_liquidity_pool<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
        Arg7: ProxyArg<BigUint<Env::Api>>,
        Arg8: ProxyArg<BigUint<Env::Api>>,
        Arg9: ProxyArg<BigUint<Env::Api>>,
        Arg10: ProxyArg<BigUint<Env::Api>>,
        Arg11: ProxyArg<bool>,
        Arg12: ProxyArg<bool>,
        Arg13: ProxyArg<bool>,
        Arg14: ProxyArg<BigUint<Env::Api>>,
        Arg15: ProxyArg<BigUint<Env::Api>>,
        Arg16: ProxyArg<bool>,
        Arg17: ProxyArg<bool>,
        Arg18: ProxyArg<bool>,
        Arg19: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
        Arg20: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        base_asset: Arg0,
        r_max: Arg1,
        r_base: Arg2,
        r_slope1: Arg3,
        r_slope2: Arg4,
        u_optimal: Arg5,
        reserve_factor: Arg6,
        ltv: Arg7,
        liquidation_threshold: Arg8,
        liquidation_bonus: Arg9,
        liquidation_base_fee: Arg10,
        can_be_collateral: Arg11,
        can_be_borrowed: Arg12,
        is_isolated: Arg13,
        debt_ceiling_usd: Arg14,
        flash_loan_fee: Arg15,
        is_siloed: Arg16,
        flashloan_enabled: Arg17,
        can_borrow_in_isolation: Arg18,
        borrow_cap: Arg19,
        supply_cap: Arg20,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createLiquidityPool")
            .argument(&base_asset)
            .argument(&r_max)
            .argument(&r_base)
            .argument(&r_slope1)
            .argument(&r_slope2)
            .argument(&u_optimal)
            .argument(&reserve_factor)
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_bonus)
            .argument(&liquidation_base_fee)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .argument(&is_isolated)
            .argument(&debt_ceiling_usd)
            .argument(&flash_loan_fee)
            .argument(&is_siloed)
            .argument(&flashloan_enabled)
            .argument(&can_borrow_in_isolation)
            .argument(&borrow_cap)
            .argument(&supply_cap)
            .original_result()
    }

    pub fn upgrade_liquidity_pool<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
        Arg5: ProxyArg<BigUint<Env::Api>>,
        Arg6: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        base_asset: Arg0,
        r_max: Arg1,
        r_base: Arg2,
        r_slope1: Arg3,
        r_slope2: Arg4,
        u_optimal: Arg5,
        reserve_factor: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("upgradeLiquidityPool")
            .argument(&base_asset)
            .argument(&r_max)
            .argument(&r_base)
            .argument(&r_slope1)
            .argument(&r_slope2)
            .argument(&u_optimal)
            .argument(&reserve_factor)
            .original_result()
    }

    pub fn set_aggregator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        aggregator: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAggregator")
            .argument(&aggregator)
            .original_result()
    }

    pub fn add_e_mode_category<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ltv: Arg0,
        liquidation_threshold: Arg1,
        liquidation_bonus: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addEModeCategory")
            .argument(&ltv)
            .argument(&liquidation_threshold)
            .argument(&liquidation_bonus)
            .original_result()
    }

    pub fn edit_e_mode_category<
        Arg0: ProxyArg<common_structs::EModeCategory<Env::Api>>,
    >(
        self,
        category: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editEModeCategory")
            .argument(&category)
            .original_result()
    }

    pub fn remove_e_mode_category<
        Arg0: ProxyArg<u8>,
    >(
        self,
        category_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeEModeCategory")
            .argument(&category_id)
            .original_result()
    }

    pub fn add_asset_to_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<bool>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
        can_be_collateral: Arg2,
        can_be_borrowed: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAssetToEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .argument(&can_be_collateral)
            .argument(&can_be_borrowed)
            .original_result()
    }

    pub fn edit_asset_in_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
        Arg2: ProxyArg<common_structs::EModeAssetConfig>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
        config: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editAssetInEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .argument(&config)
            .original_result()
    }

    pub fn remove_asset_from_e_mode_category<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u8>,
    >(
        self,
        asset: Arg0,
        category_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAssetFromEModeCategory")
            .argument(&asset)
            .argument(&category_id)
            .original_result()
    }

    pub fn edit_asset_config<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<common_structs::AssetConfig<Env::Api>>,
    >(
        self,
        asset: Arg0,
        config: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("editAssetConfig")
            .argument(&asset)
            .argument(&config)
            .original_result()
    }

    pub fn get_pool_address<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolAddress")
            .argument(&asset)
            .original_result()
    }

    pub fn register_account_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        token_name: Arg0,
        ticker: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("registerAccountToken")
            .argument(&token_name)
            .argument(&ticker)
            .original_result()
    }

    pub fn account_token(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountToken")
            .original_result()
    }

    pub fn account_positions(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPositions")
            .original_result()
    }

    pub fn deposit_positions<
        Arg0: ProxyArg<u64>,
    >(
        self,
        owner_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepositPositions")
            .argument(&owner_nonce)
            .original_result()
    }

    pub fn borrow_positions<
        Arg0: ProxyArg<u64>,
    >(
        self,
        owner_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::AccountPosition<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowPositions")
            .argument(&owner_nonce)
            .original_result()
    }

    pub fn pools_map<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolsMap")
            .argument(&token_id)
            .original_result()
    }

    pub fn pools_allowed(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolAllowed")
            .original_result()
    }

    pub fn price_aggregator_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceAggregatorAddress")
            .original_result()
    }

    pub fn asset_config<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, common_structs::AssetConfig<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAssetConfig")
            .argument(&asset)
            .original_result()
    }

    pub fn last_e_mode_category_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("lastEModeCategoryId")
            .original_result()
    }

    pub fn e_mode_category(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<u8, common_structs::EModeCategory<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEModes")
            .original_result()
    }

    pub fn asset_e_modes<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        asset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u8>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAssetEModes")
            .argument(&asset)
            .original_result()
    }

    pub fn e_mode_assets<
        Arg0: ProxyArg<u8>,
    >(
        self,
        id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<EgldOrEsdtTokenIdentifier<Env::Api>, common_structs::EModeAssetConfig>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEModesAssets")
            .argument(&id)
            .original_result()
    }

    pub fn get_collateral_amount_for_token<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account_position: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralAmountForToken")
            .argument(&account_position)
            .argument(&token_id)
            .original_result()
    }

    pub fn get_borrow_amount_for_token<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account_position: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowAmountForToken")
            .argument(&account_position)
            .argument(&token_id)
            .original_result()
    }

    pub fn get_total_borrow_in_dollars<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrowInDollars")
            .argument(&account_position)
            .original_result()
    }

    pub fn get_total_collateral_in_dollars<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalCollateralAvailable")
            .argument(&account_position)
            .original_result()
    }

    pub fn get_liquidation_collateral_available<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_nonce: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationCollateralAvailable")
            .argument(&account_nonce)
            .original_result()
    }

    pub fn get_ltv_collateral_in_dollars<
        Arg0: ProxyArg<u64>,
    >(
        self,
        account_position: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLtvCollateralInDollars")
            .argument(&account_position)
            .original_result()
    }
}
